# Definitionen
## Maschienenschnittstelle, Instruction Set Architecture (ISA)
- ISA ist Befehlsatz eines Prozessors
	- -> die Menge der Maschinenbefehle
- Unterscheidung zwischen RISC- (Reduced Instruction Set Computer) und CISC- (Complex Instruction Set Computer) Architekturen

## Assembler (Sprache)
- Ist einen maschienennahe (konkrete) Programmiersprache
- an die ISA der Zielarchitektur angelehnt
- Durch Verwendung von Namen und symbolischen Adressen wird die Nutzung der ISA vereinfacht

## Assembler (Programm)
- Systemprogramm, dass
	- Assemblerbefehle in Maschinencode transformiert und 
	- Symbolischen Namen Maschienenadressen zuweist und ein Objektprogramm erzeugt

#gbs/def Maschienenschnittstelle, ISA, Assembler 

# Vom Quellcode zum Programm
- Quellcode
	- bindet ggf weitere libraries mittels header
- Compiler
	- Preprocessor
		- bindet Dateien von header in code ein
	- Compiler
		- übersetzt von C in Assembler
- Assembler
	- Übersetzt von Maschinensprache in die ISA
- Linker (Binder) 
	- einzelne Module binden
	- produziert ELF Datei 
		- Executable linkable format
		- beginnt mit "7f" im hex Darstellung
- Loader (BS)
	- Liest ELF und lädt die Objekte in den zugehörigen Speicher


![[Pasted image 20251219121318.png|575]]

# [[GBS/1. Einführung#Prozesse|Prozesse]]

## Prozessor
![[Pasted image 20251219121940.png|500]]
- IOPL
	- in welchem betriebsmodus sich der prozessor gerade befindet
	- 2 bits -> [0, 3] darstellbar
	- verschiedene modus mit nummerierung 0-3

## Prozess im speicher
- code segment
	- read only da code unverändert sein soll
- data segment 
	- rodata
		- static constants
	- data
		- static local variablen
		- globale variablen im heap
	- heap
		- dynamically allocated
- stack segment
	- base pointer -> Anfang von jedem aufgerufenen Fkt (alte pos wird gemerkt)
		- stack frame ist von bp zu sp für jede Fkt
	- stack pointer -> wird verschoben jedes mal eine variable drauf geschoben wird
	- wächst von oben nach unten
	- lokale variblen
	- fktaufruf
	- mittlerweile fkt param nicht mehr auf den stack -> register 
- ![[Pasted image 20251219123451.png|525]]


## Prozesskontext im BS
- Abbild der CPU muss hinterlegt werden wenn einem prozess die CPU "weggenommen" wird -> bestimmte Datenstruktur

![[Pasted image 20251219123843.png|525]]
![[Pasted image 20251219123938.png|500]]

## Parallele Prozesse, Multiprogramming 
- System ist Menge von Prozessen
	- Prozesse können (quasi) parallel verarbeitet werden
	- Wechseln zwischen verschiedenen Prozessen (Scheduling)

> Warum Multiprogramming? 
- Prozesse können limitiert sein 
	- I/O bound
	- CPU bound
- -> Proz wechseln während man wartet

### Prozess-Zustände
> Zustände
- rechenwillig/ready
- rechnend/running
- wartend/blocked
- ausgelagert/swapped out

![[Pasted image 20251219124604.png|550]]
> Zustandsübergänge
- add
	- (init) -> ready
	- neu erzeigter Prozess wird zu der Menge der rechenwilligen Prozesse hinzugefügt
- assign
	- ready, running
	- als Folge eines Kontextwechsels wird dem Prozess die CPU zugeordner
- block
	- running -> blocked
	- aufgrund eines I/O-Aufrufs oder einer Synchronisationsoperation wird der Prozess auf wartend gesetzt
- ready
	- blocked -> ready 
	- nach Beendigung der angestoßenen Operation wechselt der Prozess in den Zustand rechenwillig
- retire
	- running -> (terminated)
	- der aktuell rechende Prozess terminiert
- swap out 
	- anywhere -> swapped out
	- Prozess wird auf die Festplatte ausgelagert
- swap in
	- swapped out -> ready/blocked
	- ausgelagerter Prozess wird in den Speicher gebracht

# Thread
- ein Thread wird betrachtet als eine Abstraktion eines physischen Prozessors
- repräsentieren nebenläufige Ausführungspfade eines Rechensystems
- Prozess besitzt mindestens einen Thread
- Multi-Threaded-Prozess besitzt mehrere Kontrollflüsse
- Threads eines Prozesses teilen sich dessen Adressraum
- Jeder Thread besitzt seinen eigenen Befehlszähler(instruction pointer)

![[Pasted image 20251219160838.png|400]]

#gbs/def 


## Warum Multi-Threading
> Overhead
- Thread ist ein "lightweight" Prozess 
	- -> u.a. gemeinsamer Adressraum
- Einfache Kommunikation zwischen Threads eines Prozesses über gemeinsamen Adressraum
- Aufwand, einen Thread innerhalb eines Prozesses zu erstellen, ist wesentlich geringer als einen Prozess zu erzeugen
- Threads können wesentlich schneller ihren Kontext wechseln


# Prozess vs. Thread

- Prozess ist Programm in Ausführung
	- Benutzt Ressouren
	- Hat einen Kontrollfluss (definiert durch die Instruktion des Programms)
	- -> Ressourcen und Kontrollfluss sind unabhängige Konzepte, lassen sich trennen
- Prozess gruppiert und verwaltet Ressourcen
	- Adressraum inkl. Programmcode und Daten
	- Gemeinsam nutzbare Ressourcen für alle Threads eines Prozesses
- Thread-Kontext muss gesichert werden, sobald einem Thread die CPU entzogen wird
	- running -> blocked/ready

| Per-process items                                                                                                                             | Per-thread items                               |
| --------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| Address space<br>Global variables<br>Open files<br>Child processes<br>Pending alarms<br>Signals and signal handlers<br>Accounting information | Program counter<br>Registers<br>Stack<br>State |

- Thread definiert einen Kontrollfluss

- Threads sind Aktivitätsträger
- Thread-spezifische Informationen, der Thread-Kontext
	- program counter/instruction pointer
	- Registerwerte (z.B. Variablen etc.)
	- Stack zur Verwaltung von Unterprogrammaufrufen

- Threads können auch in verschiedenen Zuständen sein 
	- ![[Pasted image 20251219161235.png|500]]

> [!question] Ressourcen vs Kontrollfluss
