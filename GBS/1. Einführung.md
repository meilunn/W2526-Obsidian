
> [!info] Aufgabe der Informatik
> Aufgabe der Informatik ist es, ==Rechensysteme== zu entwickeln und diese Anwendern als leistungsfähige ==Hilfsmittel== für Lösungen ihrer Informationsverarbeitungsprobleme zur Verfügugng zu stellen.

# Rechensystem (/Rechner/Computer)
## Definition 
- Rechensysteme sind
	- offene
	- dynamische
	- technische Systeme
- mit der Fähigkeiten zur
	- Speicherung und
	- Verarbeitung von Informationen sowie
	- der Fähigkeit zur Kommunikation

#gbs/def Rechensystem, Rechner, Computer

### Offenes System
- Besteht aus ==Komponenten== 
- Verbingungen zwischen Komponenten beschreiben ==Abhängigkeiten== 
- Besitzt ==Schnittstellen== zur externen Einwirkung auf das Sys
- so gestaltet und dokumentiert, dass die ==Schnittstellen== von Dritten genutzt werden können

> **Schnittstelle**
- z.B. Benutzerinteraktion, Netzschnittstelle
- ermöglichen verschiedene Sichten auf ein Sys
- Von außen: Black-Box-Sicht
	- Zusammenfassungen von Komponenten und Abgrenzungen zum Nutzer
- Von innen: White-Box-Sicht
	- Rekursive Aufteilung in Komponenten bzw. Sub-Komponenten
- ![[Pasted image 20251022120722.png|450]]
- Operationen wie z.B. `read, write`

### Dynamisches System
- Reighe von Eigenschaften beschreiben den ==Zustand des Systems== zu einem ==Betrachtungszeitpunkt==
	- Eigenschaften und Zustände eines Rechensystems verändern sich über die Zeit
- Eine Folge von Zuständen bzw. Zustandsänderungen beschreibt das ==Systemverhalten== 
- ==Aktive== (z.B. CPU) und ==passive== (z.B. RAM) Komponenten ermöglichen dem Rechensystem die Fähigkeit zur Zustandsänderung
	- Aktive Komponenten führen Aktionen aus, die Zustandsveränderungen bewirken
	- passive Komponente sidn Hilfsmittel für diese Aktionen

### Technisches System
- Ein Rechensystem ist mit hardware- und softwaretechnischen Mitteln realisiert


## Beispiel Raspberry Pi 4
- Eingabegerät: Tastatur
- User interface: Shell
- Befehl in Shell um ausführbares Programm auszuführen
	- Braucht zum Ausführen
		- CPU
		- Speicher
		- I/O-Geräte
		- (SD-Karte)
	- Kontrolle fällt nach Ausführung zurück an die Shell
- Hat ein Dateisystem
	- unterliegende Speichergeräte: SSD, SD-Karte
- Ausgabegerät: Bildschirm

## Von-Neumann Architektur
- ![[Von-Neumann.png|450]]
	- Bus-system ist zentrale Kommunikationssastem
		- verbindet alls Systeme
		- Übertragungsweg für Adressen, Daten, Steuersignale

## Einfache Systemstruktur
- ![[Systemstruktur.png|475]]
	- Verbindungen ist BUS


# Betriebssystem
- Allgemeine Schichtenstruktur und Einordnung des BS
	- ![[Pasted image 20251022121524.png|500]]

## Definitionen
- Nach DIN 44300 (ältere, nicht mehr aktuelle Norm für allgemeine Begriffe der Informationsverarbeitung)
	- Das BS wird gebildet durch die Programme eines digitalen Rechensystems, 
		- die zusammen mit den Eigenschaften der Rechenanlage 
		- die Grundlage der möglichen Betriebsarten des digitalen Rechensystems bilden 
		- und insbesondere die Ausführung von Programmen ==steuern und überwachen==

- Alternative Definition
	- Das BS ist selbst ==ein Programm==, das die Ausführung von System- oder Anwendungsprogrammen ==steuert und überwacht== und für die Anwendungsprogramme eine Schnittstalle zu den HW Komponenten bereitstellt

#gbs/def Betriebssystem


## Aufgaben

1. Abstraktion
	- Vereinfachung, Bereitstellung von abstrakten Konzepten und gemeinsamen Schnittstellen
	- Beispiel Zugriff auf Ein-Ausgabegeräte
		- Problem: Jedes Gerät besitzt eigenen Befehlssatz, Register usw.
		- Lösung: 
			- BS definiert einheitliche Operationen (Schnittstelle), z.B. `read, write`, die Programmierer nutzen können
			- BS setzt diese auf die Geräte-spezifischen Befehle um, unter Verwendung eines gerätespezifischen Treibers, der die Details des Geräts versteht

2. Management (von Ressourcen) -> 
	- Steuern und Kontrollieren der Programmausführung
		- "welches Programm darf wie lange ohne Unterbrachung die CPU nutzen"
	- Strategische Entscheidungen 
		- Priorisierung, Vorrang, Fairness
		- Agil, adaptiv, "Wie geht man mit spontanen Anforderungen um?"
	- Operative Entscheidungen
		- Einem Programm die CPU zu einem bestimmten Zeitpunkt zuweisen bzw. wegnehmen


> Warum (heute noch) Betriebssysteme?
- Neue, leistungsfähigere, vielfältigere HW 
- Neue Anwendungsgebiete
	- -> Spezialisierung nach unterschiedlichen Anforderungen
- Permanenter Wandel

## Betriebsarten
- je nachdem was für eine Spezialisation vom BS verschiedene Arten von BS

- Batch processing (Stapelverarbeitung)
	- Programm wird vor dem Start komplett definiert und geschlossen ausgeführt
	- Nutzer-Interaktion ist nicht vorgesehen

- Transaction system (Transaktionsbetrieb)
	- ACID-Kriterien (Atomarität, Konsistenz, Isolation, Dauerhaftigkeit) -> EIST

- Time sharing (Dialogbetrieb)
	- Interaktion zwischen dem Nutzer und dem Betriebssystem 
	- Erfordert (G)UIs
	- time sharing ist technische Implementierung, die den Dialogbetrieb für mehrere Benutzer ermöglicht

- Real time system (Echtzeitbetrieb) 
	- hard deadlines - Reaktionszeit darf nicht überschritten werden
	- soft deadlines - Gewisse Toleranzen erlaubt
	- z.B. Robotik (hard), Multimedia-Anwendungen (weich)

## Zweck 
- General Purpose
	- Linux, Win, MacOS
	- großes Fktumfang
	- komplex
- Special purpose
	- reduzierte/eingeschränkte Fktionalität
	- einfach gehalten
	- verifizierbar
	- z.B. QNX, TinyOS

## Ziele
- hohe Auslastung der HW 
- kurze Antwortzeiten
	- ->schließen sich aus
- geringer energieverbrauch -> alles was mit Batterien betrieben ist

## Typen
- Server-Betriebssysteme
	- SuperMUC, MPI
	- Dedizierte BS für Datenzentren
- Server- und Desktop-Betriebssysteme
	- Linux, Windows, MacOS
- Mobile Betriebssysteme
	- Android, iOS


## Entwicklung
### Faktoren für die Entwicklung
1. Fortschritte der Hardwaretechnologie 
	- Führt zu gutes Preis-Leistungs-Verhältnis
		- z.B. bei Festplatten
	- -> Anforderungen an das BS, u.a.
		- Schnelle Zugriffe auf gespeicherte Daten ermöglichen
		- Unterstützung von Parallelverarbeitung

2. Übergang von rein numerischer Berechnung zur allgemeinen Informationsverarbeitung
	- Man möchte interaktive Verarbeitung, Graphische Datenverarbeitung, Multimedia
	- -> Anforderungen an das BS, u.a.
		- Grafischer Nutzeroberflächen: Nutzing auch durch Nicht-Spezialisten
		- Realzeit-Unterstützung z.B. bei Verarbeitung von Videos

3. Neue Anwendungsbereiche und Digitalisierung
	- Kontext
		- Auslagerung von Diensten und Datenspeicherung an externe Anbieter (im Gegensatz zum eigenständigen Betrieb), z.B. der Server
		- Vernetzung von physischen mit digitalen Komponenten, z.B. Auto
		- Einbetten von IT in Objekte des täglichen Lebens, z.B. smart Home
	- -> Anforderungen, u.a.
		- Cloud-Computing, Virtualisierung und Containerisierung (-> Docker)
		- Eingebettete Betriebssysteme u.a. ohne Nutzerschnittstellen
### Generationen
- ![[Pasted image 20251022161705.png|500]]

----

> [!Important] ## Grundlegende Konzepte - Übersicht
> - Ressourcen (Betriebsmittel) und ihre Klassifikation 
> - Prozess als Abstraktion des Prozessors 
> - Datei als Abstraktion des Speichers 
> - Betriebssystem-Modi 
> - Systemaufrufe als Schnittstelle zwischen Anwendungsprogramm und Betriebssystem

#gbs/important Übersicht Grundlegende Konzepte

----
# Klassifikation Ressourcen
- Unterscheidungsmerkmale

> Anzahl der Nutzungen
- einmal nutzbar -> alles an Eingaben/Signale wie mausklick
- wiederholt nutzbar -> cpu

> Parallelität
- uneingeschränkt parallel benutzbar -> Dateiensystem
- Exklusiv benutzbar -> Drucker
- beschränkt parallel benutzbar -> gleichzeitiges lesen/schreiben derselben Datei

> Dauerhaftigkeit
- unterbrechbar -> CPU, Speicher, disk
- ununterbrechbar -> DVD-Rom beschreiben kann nicht unterbrochen werden

> Zentrale Ressourcen
- Prozessoren (CPUs, Rechnerkerne)
- Arbeitsspeicher

> Periphere Ressourcen
- Kommunikationseinheiten
- Speichereinheiten

> Weitere
- Aktive vs passive Ressourcen
- Hardware vs Software Ressourcen
- ...

# Prozesse
## Definition
- Programm in Ausführung
	- Programm ist eine passive Einheit, Prozess eine aktive Einheit
	- Programm kann in mehreren Prozessen (==Instanzen== des Programms) ausgeführt werden
- Sys besteht aus Menge von Prozessen
- Benötigt ==Ressourcen==, um seine Aufgaben zu erfüllen
- Enthält Programmcode, Daten, Stack

## Prozessverwaltung
- In Realität teilen sich Prozesse die Ressourcen wie CPU, Speicher
- -> Konzeptuell hat jeder Prozess für sich alleine
	- CPU/RAM
	- Speicher von 0x000000 bis 0xFFFFFF
	- -> ==Prozessadressraum==

> Virtueller Adressraum
- Ist eine Abstraktion des physischen Speichers
	- Abbildung im System: Pozessadressraum -> physikalische Adresse
- Adressräume verschiedener Prozesse sind von der Hardware gegebeinander abgeschottet
- -> BS sorgt also dafür, dass Prozesse sich unabhängig voneinander bewegen können

### Sequenzieller Prozess
- Besitzt einen Kontrollfluss (thread) mit einem Befehlszähler (program counter)
- Führt Instruktionen d. Programms sequentiell aus

### Multi-Threaded-Prozess
- Besitzt mehrere Threads
- jeder thread hat eigenen 
	- Befehlszähler
	- weitere Register
	- Stack -> mehrere Stackpointer
- ![[Pasted image 20251022164743.png|475]]

# Dateien und Dateisysteme
- hierarchisch
	- root dir
	- user dir
	- user subdir
	- user file
- linux/unix -> links

> Prinzip "Everything is a file" (Unix/Linux)
- Dateien und Verzeichnusse werden gleich behandelt und adressiert
- Ein/Ausgabegeräte
	- Tastatue, Maus, andere Peripheriegeräte: Character Special Files
	- Direkter Zugriffs auf Festplatten, CDs, DVDs, USB-Sticks, ...
		- Block Special Files
	- /dev
- Pipes
	- Verbindung zur Kommunikation zwischen zwei Prozessen
	- Benannt (names pipes, z.B. /tmp/talk-to-me) vs. unbenannt
	- $ grep "Lastname" students.txt | sort | uniq -c
- Systemzustand (Linux)
	- /proc
-> macht es leicht allgemein Code zu schreiben, da alles die gleiche Abstraktion durch das BS haben
	- man kann z.B. für alles `write()`benutzen

# Betriebssystem-Modi
- Ziel: Schutz des BS vor Programmierfehlern und Angriffen
- Lösungsansatz: Unterschiedliche Berechtigungen durch ==Arbeitsmodi== 

> Benutzermodus (User mode/space)
- Kein direkter HW-Zugriff, nur über BS
- Keine privilegierten Befehle, wie z.B. Ein-Ausgabe
- Kein oder nur lesender Zugriff auf Systemcode oder -daten
- Zugriff nur auf virtuelle Adressen
- -> Anwendungen laufen im Benutzermodus

> Systemmodus (Kernel Mode/Space)
- Privilegierter Modus, alle ausführbaren Maschienenbefehle
- Privilegierte Befehle, z.B. direkter HW-Zugriff
- Exklusiver Zugriff auf Systemcode und -daten
- -> Der Betriebssystemkern läuft im Systemmodus

- ![[Pasted image 20251022170009.png|475]]
	- blau ist Nutzeranfrage

# Systemcalls

- Aufgabe
	- Bereitstellen einer Schnittstelle, s.d. Anwendungen BS-Dienste nutzen und darüber Zugriff auf die HW erhalten können
- Lösung
	- Definition einer Menge von Diensten -> Syscalls (~Methodenaufruf)
	- Syscalls werden typischerweise nicht direkt in Anwendungen verwendet
	- Aufruf erfolgt über Systembibliotheken z.B. libc
	- Bibliotheken werden zum Anwendungsprogramm hinzugebungen -> Linker/Loader

- Beispiele
	- Dateimanagement `open, close, read, write`
	- Prozessmanagement `fork, waitpid, exit`
	- Verzeichnismanagement `mkdir, rmdir, link, unlink, mount, unmount`
	- Gerätemanagement `open, close, ioctl, fcntl`
	- Kommunikation `send, recv, connect, bind, listen, accept`

## Syscalls aus dem User Mode
- Beim booten befindet sich das System im Kernel Mode
- Bei Ausführung eines Benutzerprozesses im User Mode
- Bei Zugriff auf einen BS-Dienst (z.B. I/O) erfolgt ein Syscall, der mit einem Wechsel in den Kernel Mode verbunden ist
- ![[Pasted image 20251022170713.png|500]]

### Grober Ablauf
- Anwendung ruft Bibliotheksfunktion auf, z.B. printf()
- Bibliotheksfunktion ruft den eigentlichen Systemcall auf
- Syscall wird durch ==Trap-Instruktion== realisiert
	- Unterbrechung des aktuellen Ablaufs und Sprung in BS-Kern
- Syscall wird im Kernel Mode ausgeführt

- ![[Pasted image 20251022170933.png|325]]
	- `write(1, ...)`
		- stdin = 0
		- stdout = 1
		- stderror = 2
### Beispiel 
- `count = read(fd, buf, nbytes)`
- ![[Pasted image 20251022171944.png]]
	- (Struktur sollte umgedreht werden)
	1. Param auf den Stack (bei C von hinten nach vorne)
	2. "
	3. "
		- mittlerweile kommen die Param in den Register
	4. call read
		- neuer Stackframe für read wird aufgebaut
	5. schreibt bei Intel/AMD Prozessoren in Register `rax` die Syscall Nummer (für read 0)
	6. TRAP wird aufgerufen -> Kernel mode
		- Speichern vom CPU-Zustand (Prozess-Kontext)
	7. Dispatch liest was in `rax` ist und ruft entsprechende Fkt auf im Kern
		- hat tabelle mit Nr -> Fkt
	8. im Kern: read
	9. Rückkehr in User Mode
		- Wiederherstellen vom CPU-Zustand
	10. Rückkehr aus read-Funktionen
	11. Stack aufräumen

----

# BS-Architekturen
- Monolithische Systeme (monolithic systems)
- Geschichtete Systeme (layered systems)
- Mikrokernel-Systemen (microkernels)
- Client-Server-Systeme
- Virtuelle Maschinen

#gbs/important BS-Architekturen

## Monolithische Systeme
- Eigentschaften
	- BS umfasst umfangreiche Menge von Funktionen
	- Zusammenfassung der Fkt in einem BS-Kern
		- Alle Treiber sind innerhalb des Kernels implantiert
		- Betreten des Kerns durch Syscalls
		- Vielen Prozeduren, zu einem Executable gebunden
	- BS wird als ein (großes) Programm ausgeführt
	- arbeitet vollständig im ==Kernel Mode==
	- BS-Kern hat hohe ==Ablaufpriorität==
	- BS-Kern ist permanent im Arbeitsspeicher

- Konsequenzen
	- Sehr flexibel: Prozeduren können sich sechselseitig aufrufen
	- Fehlende Struktur -> schwer wart- und erweiterbar 
	- Wenig resilient: Crash einer Prozedur führt zu Crash des Programms

- Beispiel Unix / Linux
	- ![[Pasted image 20251022181650.png|450]]

> Varianten mit Ziel u.a. bessere Wartbarkeit
- Modularität: Erweiterbarkeit
	- Neue Module können geladen werden und die Funktionalität erweitern
- Portierbarkeit: Übertragen von SW auf andere HW
	- Innerhalb des BS werden Basisfkt bereitgestellt
	- Aufwandreduktion: nur diese Basisfunktionalität muss auf eine neue HWArchitektur portiert werden
- Geschichtete Systeme (Layers)
	- Hierarchie von Schichten oder Ringen
	- Vereinfachung durch Abstraktion

## Mikrokerne
- Problem:
	- Fehler in Software avg 2-10 Fehler pro 1000 Lines of Code
	- -> zu viel wenn man das hochskaliert
- Idee: 
	- BS in kleine Module aufteilen 
		- eigenständige Sysprozesse
		- Isolation von Fehlern
	- nur ein Modul, der *Mikrokern*, läuft im Kernel Mode
	- Kleiner Kern -> leichter wartbar
- Beispiele: L4, PikeOS, Mach, QNX, MINIX

> Ansatz
- Mikrokern bietet nur noch ==Basismechanismen== wie Prozesskommunikation (IPC) und CPU-Zuteilung (Scheduling)
	- Kern selbst leichter absicherbar, ggf. beweisbar

- Subsysteme sind als ==Systemdienste im User Mode== implementiert, keine Privilegien
	- Beispiele: Dateisystem, Speicherverwaltung oder Prozessverwaltung
	- können einfach ausgetauscht werden

- Systemfunktionen werden als ==Serverprozesse== ausgeführt
	- Benötigt eine Anwendung einen Dienst, kommuniziert sie mit dem entsprechenden Serverprozess
	- Komm zwischen Diensten erfolgt nicht direkt sondern über den BS-Kern mittels IPC: Client-Server-Prinzip

- ![[Pasted image 20251022182842.png|525]]
