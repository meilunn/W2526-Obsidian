# Camera
- translates game into 2D visual representation on screen

> Shaping the player's experience with
- Position, Angle
	- What the player sees
	- e.g. vast landscape or small room
- Perspective, FOV, Depth of field
	- stylisation of perceived scene
- Movement/lack of
	- following character(s) / remain static / move freely
	- impacts how player interacts with the environment


# Field of View
- extent of the game world visible on the screen at any given time
- measured as an angle
	- can be horizontal, vertical of diagonal, depending on game engine
- together with ==aspect ratio==, creates ==view frustrum== 

> Opening angle
- common game setting horizontal 50°-60° opening angle seems "natural"
- smaller FOV generatres zooming effect and a "tunneled" view
- larger FOV distorts view

> Aspect ratio
- Example transition from 4:3 -> 16:9 
	- one sees less bc the opening angle stays the same -> but top and bottom get cut away

> Physical screens
- common desktop setting
	- measuring from eye-screen distance -> ~40° horizontal FOV
- common game setting ~50°
	- game is slightly distorted 
	- view on virtual world is shrunk
	- parallax distortion (obj further away appear to move slower)
	- usually negligible distortion, still could lead to motion sickness

> Wayfinding
- small FOV may inhibit wayfinding of player bc player sees less & has to move cam more
- larger FOV helps player understand spatial relationships

> Field of regard
- represents ==total observable area== that a sensor or imaging sys can cover by moving or steering its FOV
- defines ==maximum coverage area== achievable by the sys
	- e.g. in some games can't look up directly
- FOR >= FOV

> [!info] diff people diff setup see diff things


# Lens & Optics
- play crucial part for the overall feel and cinematography of game
- lens params in virtual cameras also define ==visual style, scale== and ==emotional impact== in gameplay and cutscenes (not just technical)
- simulating camera ==imperfection== in game engines is very hard!
	- e.g. games on unreal engine all look the same bc camera is too perfect and wrong settings

> Focal Length
- Controls magnification and field of view

> Aperture (f-stop)
- Affects exposure and depth of field

> Focus distance
- Determines which part of the scene appears sharp

> Imperfections
- simulate real lens imperfections for realism and cinematic feel
- abberation, vignetting, bokeh shape, distortion, reflections, dirt, flares, bloom, ...

> [!example] Case study: cinematography of Star Wars Outlaws
> For which cinematography of the movies were analysed
> - bokeh chart, lens examples
> - composition 


# Relationship: Travel and Camera Control
- user interaction is between the *world* (i.e. the objects) and the *player*
	- player is divided into the character (i.e. the avatar) and the camera (i.e. the player's view)
	- ![[Pasted image 20251029105550.png|325]]

- Three distinct *spacial relationships (SRs)* between
	- world and character
		- depending on object manipulation (world) and travel (character)
	- world and camera
		- objects (world) and image (bird's eye, map, ...)
	- character and camera
		- 1st/3rd person, ...

	- each relationship has 6 degrees of freedom (DoF) per SR -> two SRs completely define the third
		- position $(p_{x}, p_{y}, p_{z})$
		- orientation $(o_{x}, o_{y}, o_{z})$

> By interacting, the player can change the SRs
- ![[Pasted image 20251029110811.png|450]]
## Issues to Consider when implementing cam control
- System Complexity
	- 2D vs 3D
- Interaction Control Schemes
	- Fixed vs automatic vs interactive
	- Position vs rate control
	- Hybrid, multiple views -> Minimaps
- UI options/implementations of diff platforms

# Game view
- designed *view* that player perceives *gamespace* with
	- depends on positions of cam, audio listener, type of camera and control scheme
- design of entire game space depending on camera settings

## Independent view
- camera is unrelated to the person -> Exo-centric view control
- In principle: 
	- 3D with 6 DoF $(T_x, T_y, T_z, R_x, R_y, R_z)$
- Frequent simplifications
	- 2D
		- mostly used
		- Fixed view + Automatically or interactively adjusted view
		- 3DoF $(T_x, T_y, \alpha)$
	- Isometric
		- slanted -> 3 DoF

- e.g. city-builder, league, civ, baldur's gate
	- although in some cases cam is not absolutely independent, e.g. following characters sometimes
### Camera Translation
- Automatically adjusted view
	- Some of the 6 DoFs depend on the character or other game obj 
	- e.g. scrolling sideways when character moves
	- incomplete Unity script: 
```cs
public Transform character; 
public float height; 

void Update()
{
	transform.position = new Vector3(character.position.x, height, 0.0f);
} 
```

## Fixed view
- view from fixed positions

> Top view (bird)
- Position: fixed height above ground (y)
- Orientation: looking down (along y-axis)

> Front view
- Position: fixed distance (z) from image plany (xy)
- Orientation: looking forward (along z-axis) parallel to the ground (xz plane)

> Slanted view
- Some fixed (suitable) position
- Some fixed (suitable) viewing orientation

> Single screen view
- special type of fixed view

- Sometimes allowed to jump between different fixed views
	- e.g. menu
	- interactive changes possible
		- different keybinds
		- different orientation

### System Complexity
- FOV *not* aligned with person's eye

| con                                | pro                                                                       |
| ---------------------------------- | ------------------------------------------------------------------------- |
| - UI should also be world-based    | - Wide view<br>-> much peripheral information, high situational awareness |
| - Low detail -> not very immersive |                                                                           |
![[Pasted image 20251029122623.png|330]]
### Camera Translation
> Isomorphic positioning
- Good for teleportation (text, input, menu selection)
- Instantaneous jump
- Automated/animated ride/fight

> Incremental motion (rate)
- Constant speed (e.g. WASD-keys)
- Constant acceleration/braking
- Speed change possible via analog slider e.g. joystick

## First-person view
- Physical eye and virtual camera have
	- same position
	- same direction
	- similar FOV properties
	
	- cam placed at "head" of the player
		- but not really, could look weird depending on FOV etc, e.g. chest
	- ![[Pasted image 20251029121424.png]]

- In principle 3D, 6 DoF
	- But movement often restricted to the ground plane
	- -> 2D, 3DoF $(T_x, T_y, R_z)$

### System complexity
- Parts of own character may be visible
	- models for other players != model of your own body parts 
	- -> 1st person models of Overwatch
- running against a wall in a shooter
	- -> model for oneself is very small but put very near in front of the cam

| con                                                                                                                                              | pro                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------- |
| - Limited view<br>-> No (little) peripheral information, lacking situational awareness<br>-> compensation needed e.g. with audio (hearing steps) | - UI should be ego-referenced   |
|                                                                                                                                                  | - High detail -> very immersive |
![[Pasted image 20251029122649.png|330]]

### Control schemes
#### Ego-Centric View Control
- cam attached to character
- update cam *pose* (position & orientation) on character move
	- 2D
		- forward, sideways (strafing) translation - $(t_x, t_z)$
		- panning (yaw) rotation $(r_y)$
	- 3D 
		- any travel motion possible -> any camera motion

> Naive Algorithm
- No special script for cam (movement) required
- In scene graph, make cam child node of character (and use travel script)

#### Gaze-Directed Travel Control
- character follows camera, travels along viewing direction
- change viewing direction only
	- Go forward/backward -> 1 DoF
	- Rotate left/right, up/down -> 1-2 DoF
	- -> strafing not possible

![[Pasted image 20251029131340.png|100]]
#### Mixed Camera-Character Control
- same translation, separate rotation
- two-handed techniques
	- keyboard + mouse
	- two-joystick technique (bulldozer technique)
- enables aiming

## Third person view
- cam outside player character's body, "follows" the character
	- -> Ego-motion view control
- many diff types
	- rotating camera, behind, fixed-perspective, over-the-shoulder

> Naive approach
- make camera child node of character, and build upon the travel script as with first-person
- camera may also need its own script (to accommodate orbiting control)

![[Pasted image 20251029133020.png|350]]

- different cam modes with diff control schemes that could switch automatically
	- bc sometimes diff modes are needed to e.g. help player better gain info, spacial awareness etc.
	- z.B. when doing different actions such as normal running, climbing, zipline
	- Challenges
		- input method/scheme also could change completely -> how to make player comfortable with switching? 
		- transitions very hard to implement (well)

- -> case study: Elden Ring 
	- First entrance into Limgrave
		- cam will show the entirety of limgrave no matter what, bc player will go through the door and cam will follow and it only has "one" path to go
		- -> clearly shows goals/next steps in the game
	- when riding, cam flattens slightly and zooms out -> increase FOV to let players take in the world and set next goal

### System Complexity
- 3D with 6 DoF
- character is fully visible, close to the img center
- char is followed by a cam, with the cam view in a *suitable place* behind/to the side of the char
	- -> intelligent automatic cam adjustment
- Other extensions
	- Player can orbit the cam around the character
	- Strafing
	- Avoid occluding obstacles between cam and char
	- Show relevant scene parts around the character -> what player must see 

#### Cam control solutions
> Rigid transformation/camera attachment (fixed)
- cam at *fixed distance* behind avatar
- looking at avatar
- when char turns, cam automatically rotates accordingly
- ![[Pasted image 20251029133721.png|450]]

> Orbiting camera/view adjustement
- allow player to interactively change cam pos behind the character
- always looking at character
- on player input, *calculate angular offset* to player orientation (yaw, pitch), and then position cam on the orbit according to this offset
- ![[Pasted image 20251029134014.png|450]]
- incomplete Unity script
```cs
// ThirdPersonCamera.cs

public Transform orbit_pivot = transform.parent; 
public float radius = 2;
private float yaw = 0;
private float pitch = 0;

void Update() 
{
	transform.position = orbit_pivot.position; 
	transform.rotation = orbit_pivot.rotation;
	
	yaw += (Input.GetAxis("Mouse X") * yaw_scale);
	pitch -= (Input.GetAxis("Mouse Y") * pitch_scale);
	radius += Input.mouseScrollDelta.y;
	
	transform.Rotate(new Vector3(0.0f, yaw, 0.0f));
	transform.Rotate(new Vector3(pitch, 0.0f, 0.0f));
	transform.Translate(new Vector(0.0f, 0.0f, -radius));
}
```

> Mixed Camera-Character Control
- allows player to change char orientation based on current cam view
- ![[Pasted image 20251029134824.png|450]]
```cs
// Camera script ThirdPersonCamera.cs
// In player.cs script: 

ThirdPersonCamera camOrbit
		= GameObject.Find("ThirdPersonCamea").
			GetComponent<ThirdPersonCamera>;
			
void Update() 
{
	// align player with 3rd view cam
	Vector3 pDir = transform.rotation.eulerAngles;
	Vector cDir = camOrbit.transform.rotation.eulerAngles;
	transform.rotation = Quaternion.Euler(pDir.x, cDir.y, pDir.z);
	
	// reset orbitting direction of camera
	camOrbit.SetYaw(0.0f);
}
```

#### Automatic Adjustments
> Dynamic sling rope transformation
- Length preserving
- Reacts to radical acceleration
- Camera has mass - apply inertia
- ![[Pasted image 20251029150813.png|227]]

> Rigid plus tethered transformation
- add a tether "below" the transformation to the third person's viewpoint
- damped mass-spring model
- ![[Pasted image 20251029150920.png|205]]

> Facing direction-related dynamic tethered transformation
- view direction of camera aims towards a point (of interest) in front of the facing direction of the user
- supports strafing by allowing user to perceive where they are going
- ![[Pasted image 20251029151050.png|350]]

## Limited Views
#### Side-Scrolling View
- 2D or 2.5D with parallax or even 3D (with/without spatial distortion?)
- can be implemented as independent views or 3rd person views

#### Top-Down View
- gameplay is viewed from above the player character
- no sight lines
- create opportunities for orientation
- axis-aligned (following cardinal directions north, south, east, west) or allow for free rotation around the global up axis
- can be implemented as independent views or 3rd person views, depending on relation between cam and char

> Potential for Hitchcock-style suspence, as player can see what player character may not be able to. E.g. next room

## Axonometric View
- without perspectival distortion -> no vanishing point
- ![[Pasted image 20251029152339.png|201]]

## 2D Views
- can show player things that are beyond eyesight of player character
- ![[Pasted image 20251029152501.png|201]]

## Mixed Views
- camera views in games cannot be categorised clearly for every game
	- ![[Pasted image 20251029152610.png|332]]
- many games mix different game views and transition between them
	- e.g. 3rd person for character <-> view map

> "raus zoomen" von 1st into 3rd/independent -> man sieht direkt wo man selber ist

## Scrolling

> One at a time
- ![[Pasted image 20251029152840.png|257]]

> Scrolling at some extent
- one scenery per screen 
- larger-than-screen segments are scrolled 
- Wayfinding issue: potentially difficult to stitch mental map

> Separate Screens
- exact alignment of different screens (fit together when stitched)
- creates a more consistent and believable world
- allows structured search for hidden areas

> Constant "scrolling" in 3D
- scene is loaded granularly while moving throught the world

> [!warning] Presence vs. Immersion
> Immersion is the technical quality of a virtual environment and the extent to which it engages a user's senses. 
> Presence is the subjective, psychological feeling of "being there" in that virtual world.

# Visual display types

> Monitors
- monocular depth cues
	- visual clues that allow perception of depth and distance using only one eye
- stereoscopic depth cues (should be >= 100 Hz)
	- active glasses ("shutter glasses")
	- passive glasses
	- spectral multiplexing (anaglyphic stereo)
	- polarasation multiplexing
- "Fishtank VR"
	- required head tracking 

> Auto Stereoscopic Displays
- No shutter glasses
- Lenitcular: Vertical grating in front of the display screen
- Holographic: Reproduction of the properties of light waves
- ![[Pasted image 20251029154152.png|375]]

> Tablets and Phones
- sometimes autostereoscopic
- retina display (Apple)
	- High pixel density (326 ppi) -> eye cannot distiguish individual pixels
	- minimally focusable distance <-> typical viewing distance

> Heads-up Displays (HUDs)
- "keep your head up"
- for non-game related as well

> Head-Mounted VR Displays (HMDs)
- Hands-free full (360°) Field of Regard
- Individual active viewpoints for each eye
- Challenges
	- FOV and Resolution getting better
	- Unknown individual interocular distance
	- Disparity of sensed motion cues
	- May get uncomfortable
	- VR vs AR
	- New relevant direction in gaming? 

> Head-Mounted AR Displays
- Optical see-through
- Video see-through
- Small FOV (30-60°)

> "Arm-"Mounted Displays (tracked AR, VR)
- often tablets or mobile phones
- Full 360° field of regard
- often implemented as a window into the virtual or augmented world
- e.g. pokemon go -> phone is arm mounted

> Surround-Screen Displays (CAVEs)
- 3-6 big projection displays 
- typically rear-projected

| pros                 | cons          |
| -------------------- | ------------- |
| large FOR, FOV       | cybersickness |
| peripheral vision    | expensive     |
| depth cues           |               |
| motion parallax      |               |
| stereoscopic viewing |               |
> [!info] Cybersickness
> Cybersickness is akin to motion sickness, but it happens while using electronic screens rather than through actual movement.

> Large Projection Walls
- Workbenches
	- 2 Display surfaces
	- L-shaped
	- Stereoscopic
	- Motion parallax (limited mobility)
- Hemispherical Displays
	- 180° FOV
	- Spherical Projection
	- Front-projected (brighter)


# Depth Cues

> How do we perceive depth on flat displays?

## Human Vision & Oculomotor cues

> Accommodation
- human vision is sharpest in central part of visual field (fovea), becomes more blurry towares the periphery
- to see sharp images, the lens in the eye changes shape in order to let light from "every" angle hit the fovea

> Convergence
- Eyeballs tilt inwards in order to see details of the obj
- ![[Pasted image 20251105103626.png|158]]

> Stereopsis
- seeing in stereo (by two sensors/eyes)
- leads to *disparity* -- difference in image location between left and right eye
- ![[Pasted image 20251105103750.png|270]]

> Angular Size 
- is the angle an object occupies on the retina 
- depends on the obj's actual size and distance from the observer
	- distance increase -> angular size decrease
- Familiar obj (like humans or cars) help us judge distance and depth using perceived size

## To make humans perceive depth

> Stereo Display
- show two images on screen on purpose to make human see two different images, as one would when looking at something in the distance 
- faked distance of the shown scene on screen != actual distance of screen 
	- -> accommodation-convergence mismatch
	- could cause motion sickness

> Monocular, Static cues
- Relative size
- Height relative to the horizon
- Occlusion
- Linear perspective
- Aerial perspective (atmospheric attenuation - things appear less saturated & blue in the distance)
- Shadows, lighting
- Texture gradient
- Depth of Focus
- ![[Pasted image 20251105105003.png|297]]

> Motion Parallax
- Stationary motion parallax: Obj move relative to stationary viewer
- Moving-viewer motion parallax: viewer moves relative to stationary obj
- Hybrid motions: obj and viewer move

- Close obj move faster across visual field than distant obj
	- -> Dynamic depth cue

----
## Case Study: Disneyland's use of forced perspective 

> Houses on main street 
- ![[Pasted image 20251105105526.png|425]]
- make upper stories appear even more distant (and so the house taller) by reducing their sizes

> Castle
- wide, life-sized base, thin towers -> towers appear taller
- no elements on the outside that let you deduce amount of stories
- taller -> colours get paler

> Tower of Terror
- fixed viewpoint from elevator
- hallway is more narrow at the end
- ![[Pasted image 20251105111404.png|425]]

> Cars land
- paint rocks that need to be further away in less saturated
- ![[Pasted image 20251105111500.png]]

