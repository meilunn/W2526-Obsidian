
> [!info] What is ts?
> - designed *view* that player perceives *gamespace* with
> - depends on positions of cam, audio listener, type of camera and control scheme
> - design of entire game space depending on camera settings

# Independent view
- camera is unrelated to the person -> Exo-centric view control
- In principle: 
	- 3D with 6 DoF $(T_x, T_y, T_z, R_x, R_y, R_z)$
- Frequent simplifications
	- 2D
		- mostly used
		- Fixed view + Automatically or interactively adjusted view
		- 3DoF $(T_x, T_y, \alpha)$
	- Isometric
		- slanted -> 3 DoF

- e.g. city-builder, league, civ, baldur's gate
	- although in some cases cam is not absolutely independent, e.g. following characters sometimes
### Camera Translation
- Automatically adjusted view
	- Some of the 6 DoFs depend on the character or other game obj 
	- e.g. scrolling sideways when character moves
	- incomplete Unity script: 
```cs
public Transform character; 
public float height; 

void Update()
{
	transform.position = new Vector3(character.position.x, height, 0.0f);
} 
```


# Fixed view
- view from fixed positions

> Top view (bird)
- Position: fixed height above ground (y)
- Orientation: looking down (along y-axis)

> Front view
- Position: fixed distance (z) from image plany (xy)
- Orientation: looking forward (along z-axis) parallel to the ground (xz plane)

> Slanted view
- Some fixed (suitable) position
- Some fixed (suitable) viewing orientation

> Single screen view
- special type of fixed view

- Sometimes allowed to jump between different fixed views
	- e.g. menu
	- interactive changes possible
		- different keybinds
		- different orientation

### System Complexity
- FOV *not* aligned with person's eye

| con                                | pro                                                                       |
| ---------------------------------- | ------------------------------------------------------------------------- |
| - UI should also be world-based    | - Wide view<br>-> much peripheral information, high situational awareness |
| - Low detail -> not very immersive |                                                                           |
![[Pasted image 20251029122623.png|330]]
### Camera Translation
> Isomorphic positioning
- Good for teleportation (text, input, menu selection)
- Instantaneous jump
- Automated/animated ride/fight

> Incremental motion (rate)
- Constant speed (e.g. WASD-keys)
- Constant acceleration/braking
- Speed change possible via analog slider e.g. joystick


# First-person view
- Physical eye and virtual camera have
	- same position
	- same direction
	- similar FOV properties
	
	- cam placed at "head" of the player
		- but not really, could look weird depending on FOV etc, e.g. chest
	- ![[Pasted image 20251029121424.png]]

- In principle 3D, 6 DoF
	- But movement often restricted to the ground plane
	- -> 2D, 3DoF $(T_x, T_y, R_z)$

### System complexity
- Parts of own character may be visible
	- models for other players != model of your own body parts 
	- -> 1st person models of Overwatch
- running against a wall in a shooter
	- -> model for oneself is very small but put very near in front of the cam

| con                                                                                                                                              | pro                             |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------- |
| - Limited view<br>-> No (little) peripheral information, lacking situational awareness<br>-> compensation needed e.g. with audio (hearing steps) | - UI should be ego-referenced   |
|                                                                                                                                                  | - High detail -> very immersive |
![[Pasted image 20251029122649.png|330]]

### Control schemes
#### Ego-Centric View Control
- cam attached to character
- update cam *pose* (position & orientation) on character move
	- 2D
		- forward, sideways (strafing) translation - $(t_x, t_z)$
		- panning (yaw) rotation $(r_y)$
	- 3D 
		- any travel motion possible -> any camera motion

> Naive Algorithm
- No special script for cam (movement) required
- In scene graph, make cam child node of character (and use travel script)

#### Gaze-Directed Travel Control
- character follows camera, travels along viewing direction
- change viewing direction only
	- Go forward/backward -> 1 DoF
	- Rotate left/right, up/down -> 1-2 DoF
	- -> strafing not possible

![[Pasted image 20251029131340.png|100]]
#### Mixed Camera-Character Control
- same translation, separate rotation
- two-handed techniques
	- keyboard + mouse
	- two-joystick technique (bulldozer technique)
- enables aiming


# Third person view
- cam outside player character's body, "follows" the character
	- -> Ego-motion view control
- many diff types
	- rotating camera, behind, fixed-perspective, over-the-shoulder

> Naive approach
- make camera child node of character, and build upon the travel script as with first-person
- camera may also need its own script (to accommodate orbiting control)

![[Pasted image 20251029133020.png|350]]

> Using different camera modes
- different cam modes with diff control schemes that could switch automatically
- bc sometimes diff modes are needed to e.g. help player better gain info, spacial awareness etc.
- z.B. when doing different actions such as normal running, climbing, zipline
- Challenges
	- input method/scheme also could change completely -> how to make player comfortable with switching? 
	- transitions very hard to implement (well)


> Case study: Elden Ring's highly controlled camera
- First entrance into Limgrave
	- cam will show the entirety of limgrave no matter what, bc player will go through the door and cam will follow and it only has "one" path to go
	- -> clearly shows goals/next steps in the game
- when riding, cam flattens slightly and zooms out -> increase FOV to let players take in the world and set next goal

### System Complexity
- 3D with 6 DoF
- character is fully visible, close to the img center
- char is followed by a cam, with the cam view in a *suitable place* behind/to the side of the char
	- -> intelligent automatic cam adjustment
- Other extensions
	- Player can orbit the cam around the character
	- Strafing
	- Avoid occluding obstacles between cam and char
	- Show relevant scene parts around the character -> what player must see 

### Cam control solutions
#### Rigid transformation/camera attachment (fixed)
- cam at *fixed distance* behind avatar
- looking at avatar
- when char turns, cam automatically rotates accordingly
- ![[Pasted image 20251029133721.png|450]]

#### Orbiting camera/view adjustement
- allow player to interactively change cam pos behind the character
- always looking at character
- on player input, *calculate angular offset* to player orientation (yaw, pitch), and then position cam on the orbit according to this offset
- ![[Pasted image 20251029134014.png|450]]
- incomplete Unity script
```cs
// ThirdPersonCamera.cs

public Transform orbit_pivot = transform.parent; 
public float radius = 2;
private float yaw = 0;
private float pitch = 0;

void Update() 
{
	transform.position = orbit_pivot.position; 
	transform.rotation = orbit_pivot.rotation;
	
	yaw += (Input.GetAxis("Mouse X") * yaw_scale);
	pitch -= (Input.GetAxis("Mouse Y") * pitch_scale);
	radius += Input.mouseScrollDelta.y;
	
	transform.Rotate(new Vector3(0.0f, yaw, 0.0f));
	transform.Rotate(new Vector3(pitch, 0.0f, 0.0f));
	transform.Translate(new Vector(0.0f, 0.0f, -radius));
}
```

#### Mixed Camera-Character Control
- allows player to change char orientation based on current cam view
- ![[Pasted image 20251029134824.png|450]]
```cs
// Camera script ThirdPersonCamera.cs
// In player.cs script: 

ThirdPersonCamera camOrbit
		= GameObject.Find("ThirdPersonCamea").
			GetComponent<ThirdPersonCamera>;
			
void Update() 
{
	// align player with 3rd view cam
	Vector3 pDir = transform.rotation.eulerAngles;
	Vector cDir = camOrbit.transform.rotation.eulerAngles;
	transform.rotation = Quaternion.Euler(pDir.x, cDir.y, pDir.z);
	
	// reset orbitting direction of camera
	camOrbit.SetYaw(0.0f);
}
```

#### Automatic Adjustments
> Dynamic sling rope transformation
- Length preserving
- Reacts to radical acceleration
- Camera has mass - apply inertia
- ![[Pasted image 20251029150813.png|227]]

> Rigid plus tethered transformation
- add a tether "below" the transformation to the third person's viewpoint
- damped mass-spring model
- ![[Pasted image 20251029150920.png|205]]

> Facing direction-related dynamic tethered transformation
- view direction of camera aims towards a point (of interest) in front of the facing direction of the user
- supports strafing by allowing user to perceive where they are going
- ![[Pasted image 20251029151050.png|350]]

# Limited Views
#### Side-Scrolling View
- 2D or 2.5D with parallax or even 3D (with/without spatial distortion?)
- can be implemented as independent views or 3rd person views

#### Top-Down View
- gameplay is viewed from above the player character
- no sight lines
- create opportunities for orientation
- axis-aligned (following cardinal directions north, south, east, west) or allow for free rotation around the global up axis
- can be implemented as independent views or 3rd person views, depending on relation between cam and char

> Potential for Hitchcock-style suspence, as player can see what player character may not be able to. E.g. next room

## Axonometric View
- without perspectival distortion -> no vanishing point
- ![[Pasted image 20251029152339.png|201]]

## 2D Views
- can show player things that are beyond eyesight of player character
- ![[Pasted image 20251029152501.png|201]]

# Mixed Views
- camera views in games cannot be categorised clearly for every game
	- ![[Pasted image 20251029152610.png|332]]
- many games mix different game views and transition between them
	- e.g. 3rd person for character <-> view map

> "raus zoomen" von 1st into 3rd/independent -> man sieht direkt wo man selber ist


# Scrolling

> One at a time
- ![[Pasted image 20251029152840.png|257]]

> Scrolling at some extent
- one scenery per screen 
- larger-than-screen segments are scrolled 
- Wayfinding issue: potentially difficult to stitch mental map

> Separate Screens
- exact alignment of different screens (fit together when stitched)
- creates a more consistent and believable world
- allows structured search for hidden areas

> Constant "scrolling" in 3D
- scene is loaded granularly while moving throught the world


> [!warning] Presence vs. Immersion
> Immersion is the technical quality of a virtual environment and the extent to which it engages a user's senses. 
> Presence is the subjective, psychological feeling of "being there" in that virtual world.

