# Travel Tasks
- Three types needed/used distinguished by user's goal

> Exploration
- environment is *unknown to the player*
- environment needs to be explored to *gain spacial knowledge*
- player has *no explicit goal*

- often at beginning of game or when new environment is reached
- movement cannot be predicted
- UI Requirements
	- allow for continuous, direct control of the viewpoint
	- interruption of animated viewpoint control
	- little cognitive load on user on understanding technique used to travel

> Search
- travelling to a *specific goal of target location* within new environment
- Two ways for players to search
	- <u>Naive target-based search</u>: 
		- player acquiring additional spatial knowledge while searching
		- exploring the environment until objective is found
	- <u>Primed target-based search</u>: 
		- player uses *pre-existing* spacial knowledge to find goal
- goal oriented UI
	- let player specify destination on a map (-> given that destination is shown on map)
	- show direction toward goal or complete route either in world or on map

> Maneuvering
- *small, precise movements* in small area -> boss fights, jump n run
- includes repositioning local viewpoint
- can cost players lots of time and cause major frustrations (independent of an adequate implementation)
- UI requirements
	- Great precision of motion
	- very fast
	- tight feedback look

## Characterisation of travel tasks
- usually a secondary task -> technique needs to be <u>unobtrusive, intuitive and easily controlled</u>
- multiple factors taken into account to characterise travel tasks

> Distance to be traveled
- Short-range -> requires high precision
- Medium-range
- Long-range -> can be realised with velocity control or teleportation

> Amount of curvature or number of turns in the path
- Little -> Steering-based on torso-direction
- Much -> Pointing-based travel

> Visibility of target from starting location
- if target is visible, gaze-based techniques can be used

> Number of DoFs required for the movement
- Motion in a horizontal plane (driving, walking)
- Motion in 3D (flying, parkouring)

> Required accuracy of movement
- High accuracy requires a technique that allows for
	- fine control of direction, speed, and targeting location 
	- easy error recovery
- Medium/Low accuracy -> Map-based techniques

# Isomorphic Travel
- one-to-one mapping of input to output
- Special variations
	- target selection
		- target is selected via one-to-one mapping 
		- travel mode *f* along path is determined by system
	- fast travel/teleportation 

## Principles

> Pose of input device
- Absolute (direct) pose
	- input mapped "one-to-one" to the new position
- Relative (indirect) pose
	- input is transformed into the new position relative to a starting point of the input device and its local coord sys
- ![[Pasted image 20251105115603.png|183]]

> Input frequency
- influences sys behaviour
- Once (e.g. button click) -> sys can jump to new pose
- Repeated (e.g. dragged mouse) -> sys follows path indicated by user

> Target Selection
- interaction method to select target can vary
- via picking on the screen (e.g. in a map, in 3D environment)
- via picking item on a list (e.g. in GUI, via speech)

> Mathematical concept 
- $\text{new pose} = \text{computer input}$
- or $\text{new pose} = f(\text{user interaction})$
	- for a "very simple" f

> Variations
- Conversion: user input -> new 3D pose
- Direct jump (e.g. teleportation)
- Animation
	- Speed (fixed or dynamic) 
	- Travel path (direct path/flight or with obstacles/waypoint)

## Map-based Teleportation (Target Selection)
- directly going to specified location via
	- teleportation 
	- automated path traversal
	- "wornholes" (?)

- usually decreases player's spacial orientation
	- -> would need time after travel to re-orientate

> Map-based target specification with <u>teleportation</u>
- player specifies target location in 2D map or WIM (World-in-Miniature) by
	- clicking on a mini overview map
	- positioning an avatar
	- etc

> with <u>automatic route traversal</u>
- player specifies target location in 2D map/WIM
- sys ==generates a path== from current location to target location
- selected obj moves automatically to target location

- -> Implemented using ==NavMesh==
	- Pathfinding: Dijkstra's alg, DFS, A*
		- time-consuming for large worlds -> use only for small *vicinity*
		- NavMesh is baked or continuously updated during gameplay
			- e.g. when another character enters a field on route
			- when a char reaces the end of a vicinity
	- General Issues
		- Handle terrain characteristics
		- handle occlusions with other obj <- avater/obj shapes


# Non-Isomorphic Travel
- use of some ==scales linear/non-linear mapping== of input to output
- special variation is **incremental travel**
	- player moving in steps through interface/environment by pressing directional buttons or holding a joystick
	- progresses gradually

## Principles

> Ways to indicate change
- physical motion
	- mouse, joystick
	- smartphone (tracked by IMU-Inertial Measurement Unit)
	- walking (tracked by GPS, cams)
- constant activity over extended amount of time
	- Key presses (WASD)

> Controls can be applied via
- Isometric joystick
	- interaction via force
	- handle is *seemingly stationary* (e.g. has very strong springs)
	- measures *pressure*
- Isotonic joystick 
	- interaction via movement
		- handle *changes position when pushed* 
		- measures *displacement* 

> Concept of Implementation
```cs
void Update() {
	float stepForward = Input.GetAxis("Horizontal") * Time.deltaTime * TSpeed;
	float stepSideways = Input.GetAxis("Vertical") * Time.deltaTime * TSpeed;
	float yaw = Input.GetAxis("Mouse X") * Time.deltaTime * RSpeed;
	
	transform.Translate(new Vector3(stepSideways, 0.0f, stepForward));
	transform.Rotate(new Vector3(0.0f, yaw, 0.0f));
}
```


> [!info] Isomorphic vs Non-isomorphic - Key difference
> Isomorphic control is a **one-to-one mapping** of input to output
> Non-isomorphic uses some **scaled linear/non-linear mapping**

# Input-Control Mapping
![[Pasted image 20251113140912.png]]
> Variations
- Positioning in diff spaces (2D plane with 2-3 DoFs, 3D space with 4-6 DoFs)
- Translation
	- Forward/backward
		- Define: which direction is "forward"?
			- Up/down or left/right with relation to the screen (2D platformers)
			- Along character's z-axis (3D)
		- Define: stepsize (fixed, dynamic, automatic depending on game level)
	- Sideways (strafing)
		- Along character's x-axis (perpendicular to first person's viewing direction)
- Rotation (orientation change)
	- Turn left/right -> Around y-axis