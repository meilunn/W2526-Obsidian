- Application Binary Interface
- Schnittstelle eines Software Moduls auf Maschinen-Ebene
	- z.B. Funktion, Betriebssystem
	- Sorgt dafür dass Software Module unterschiedlicher Compiler oder Sprachen zusammenarbeiten können

> Definiert werden
- Datentypen (Größe, Alignment, Layout von structs)
- Calling convention von Funktionen
	- Ort der Funktionsparameter - `rdi, rsi, rdx, rcx, r8, r9, stack`
		- Auf dem Stack `rsp + 0x8 (byte), rsp + 0x10` usw.
	- Ort der Rückgabewerte - `rax, rdx` (Konkateniert falls Rückgabewert 128Bit groß ist)
	- Welche Register zu sichern sind oder überschrieben werden können
- Speicherstruktur
- Betriebssystemschnittstelle


# Calling Convention

## Registertypen
> Callee-Saved Register
- Gehören aufrufender Funktion
- Müssen vom callee gesichert werden
- Nach Funktionsende unverändert 
- `rbx, rbp, r12-15, rsp`

> Temporäre/caller-saver Register
- Gehören aufgerufener Funktion
- Dürfen frei verwendet werden
- Nach Funktionsende undefiniert
- `rax, rcx, rdx, rsi, rdi, r8-11`

![[Pasted image 20251102154356.png|300]]

## Stack-Alignment
- Calling Convention stellt Anforderung an Stack-Alignment
- 16-Byte-Alighment vor einem Funktionsaufruf -> rsp % 16 \== 0
- `call` legt 8 Byte auf den Stack durch pushen der Return Adresse
	- Am Funktionsanfang Stack nicht aligned
	- Wenn man noch eine Funktion aufrufen will muss man also zuerst Alignment wiederherstellen z.B. mit push
- ![[Pasted image 20251102155535.png|300]]

## Structs

### Layout
- Abhängig von Reihenfolge und Alignment der Felder
- Padding um Alignment der Felder sicherzustellen
- Alignment des structs ist das seines Felds mit dem größten Alignment
- Größe des structs ist ein Vielfaches von seinem Alignmemnt -> Padding am Ende

### Als Funktionsparameter
- Falls größer als 16 Byte oder hat Felder die nicht aligned sind
	- Übergabe via Stack
- Sonst
	- Aufteilen in max. 2 Teile mit jeweils 64 Bit
	- Diese werden als Int-Parameter behandelt
	- Mehrere benachbarte Felder können zusammengefasst werden

> Beispiele
- 2 64-Bit int
```c
void func(struct { uint64_t a; uint64_t b; } param);
//a -> rdi, b -> rsi
```

- 2 32-Bit int
```c
void func(struct { uint32_t a; uint32_t b; } param);
// a -> rdi[31:0], b -> rdi[63:32]
```

- mehrere zusammengefasste Felder
```c
void func(struct { uint16_t a; uint16_t b; uint8_t c; } param);
// a -> rdi[15:0], b -> rdi[31:16], c -> rdi[39:32]
```

- struct größer als 16 Byte
```c
void func(struct { uint64_t a; uint64_t b; uint64_t c; } param);
// a -> [rsp], b -> [rsp + 8], c -> [rsp + 16]
```


### Als Rückgabewerte
- Register
	- rax und rdx für die 64-Bit-Blöcke
- Stack
	- Caller reserviert ausreichend Speicher
	- Pointer daraf wird in rdi "verdeckt" übergeben
	- Funktion gibt den Pointer in rax zurück

> Beispiel
```c
struct ComputeRes { uint64_t a, b, c; };

struct ComputeRes compute(int param);
// verhält sich wie
struct ComputeRes* compute(struct ComputeRes* retval, int param);
```

## Zusammenfassung
![[Pasted image 20251102162318.png|550]]
#asp/important Calling Convention