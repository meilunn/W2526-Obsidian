> Speicherverwaltung auf Stack und Heap

![[Pasted image 20251107222119.png]]
- `.text`: Programmcode - readonly, executable
- `.rodata`: globale konstante initialisierte Variablen - readonly
	- z.B. `const int i = 42;` (global)
- `.data`: globale initialisierte Variablen - read-write
	- z.B. `int i = 42;` (global)
- `.bss`: globale Variablen, die mit 0 initialisiert sind und nur deklarierte Variablen in Funktionen, die undefiniert sind
	- z.B. `int i;` (global)

## Stack
- 8-16 MB
- für kleine Datenmengen
- wächst von oben nach unten
- LIFO
- enthält lokale Variablen
- Automatische Speicherfreigabe nach [[V1. Stack#Funktionsaufrufe|Funktionsende]]

## Heap
- Dynamische Allokation und Freigabe
- Für größere Datenmengen
- Allokationen (Pointer) global Verwendbar

### Speicherallokation
- `void* malloc(size_t size);`
- `void* calloc(size_t nmemb, size_t size);`
	- Alloziierter Speicherbereiche wird mit 0 initialisiert

> [!warning] Immer auf NULL-Pointer Rückgabe überprüfen! 
> - `abort()`

- Pointer müssen gefreed werden
> [!warning] Nur ORIGINAL ptr von malloc, calloc etc. freen!

- `void* realloc(void* ptr, sizt_t size):`
	- ptr alter Speicher, size neue size
	- Alter Speicher bei Erfolg automatisch freigegeben
	- Vergrößerung: Neue Daten uninitialisiert
	- `realloc(NULL, size) <=> malloc(size)`
	- NULL-Pointer Rückgabewert -> Alter Speicherbereich wird nicht freigegeben

- `void* aligned_alloc(size_t alignment, size_t size);`
	- alignment muss Zweierpotenz sein
	- size muss Vielfaches des alignments sein

- `void* alloca(size_t size);`
	- allocates on stack