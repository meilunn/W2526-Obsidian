#  Buffer Overflows
- Buffer generell gebraucht, um Daten abzulegen

- BO ist Lesende bzw. schreibende Zugriffe über die Grenzen des Buffers hinaus
- BO ist häufig auftretende Sicherheitslücke
	- Beispielhafter angriff: Überschreiben der Rücksprungadresse
	- Ermöglicht Sprünge zu beliebigen Funktionen im Programm
	- Overflows von nur einem Byte können schon Sicherheit beeinträchtigen

# Segmentation Faults
- Speicherschutzverletzing, z.B.
	- Schreibenden Zugriff auf read-only Daten
	- Zugriff auf Daten mit fehlenden Berechtigungen (z.B. Kernel-Daten als Benutzer)
	- Null-Pointer Derefenzierung
	- Fehlerhafte Speicherzugriffe durch Verletzung der Calling Convention
	- usw

#### Mögliche Ansätze zur Vermeidung
- Pointer vor Benutzung überprüfen (ob NULL zurückgegeben wurde aus vorheriger Funktion)
- Fehler bei Einhaltung der Array-Grenzen überprüfen
	- Off-By-One Fehler
	- Hardcoding von Arraygrößen
- Beachtung des Nullterminals bei C-Strings überprüfen
	- Vergessen des Nullterminals
	- Speicher zu klein für Nullterminal

# Inhärent Unsichere Funktionen
- Wenn möglich Funktionen verwenden, die Schutzmechanismen erzwingen
	- z.B. `memcpy(void* dest, const void* src, size_t n);`, n gibt explizit Größe der Daten an
- C-Standardbib hat viele potenziell gefährliche Funktionen

> `gets(char* buf);
- Ab C11 nicht mehr Teil des Standards
- Liest Daten in buf bis EOF oder \n erkannt wird
- Nutzer kann im Prinzip Buffergröße bestimmen

> `scanf("%s", buf)`
- auch keine Einschränkung von maximale Zeichen
- Hängt ein Nullbyte an 

> [!check] `fgets(char* dest, int n, FILE* stream)`
> - Stattdessen immer verwenden! 
> - Höchstens (n-1) Zeichen werden eingelesen

> `strcpy(char* dest, const char* src)`
- Problem falls size(src) > size(dst)

> [!check] `strncpy(char* dest, const char* src, size_t n);`
> - Param n bestimmt, wie viele Bytes maximal kopiert werden
> - Resultat aber nur nullterminiert, wenn ein Nullterminal in den n Bytes von src existiert!

> `strcat(char* dest, const char* src);
- Hängt src an dest
- überschreibt Nullterminal von dest, Resultat ist immer nullterminiert
- Problem falls size(dest) - size(src) < 0

> [!check] `strncat(char* dest, const char* src, size_t n);`
> - Param n ist wie viele Bytes von src maximal verwendet werden
> - Sonderregel: ist size(src) >= n, muss src kein Nullterminal enthalten
> - Resultat ist immer nullterminiert
> 	- Wenn also size(src) >= n, werden n+1 Bytes in dest geschrieben
> - -> Vorsicht: Es muss immer ==size(dest) > strlen(src) + n== gelten, sonst vielleicht BO!


# Format String Injection
- wenn bei printf keine Params zu Format Specifiern angegeben werden, werden automatisch die Register und danach der Stack ausgelesen
- User könnte selber Format Specifier angeben und damit dann auf den Register/Stack zugreifen
	- mit %x, %s etc. leaken oder mit %n schreiben

# Memory Leak
- Angeforderter Speicher im Heap wird nicht wieder freigegeben
- Führt in größeren Programmen zu extremem Speicherbedarf
- -> vor return Statements immer alle durch malloc, calloc etc. belegten Speicherbereiche freigeben!
	- außer Funktion gibt Pointer von heapalloziertem Speicher zurück

# Use after Free, Double Free
- -> undefined behaviour


> [!example] Undefined Behaviour
> - Dereferenzierung von Nullpointer
> - Double Free
> - Use after free
> - Lesen uninitialisierter Variablen
> - Signed Int Overflow
> - Shift um Länge eines Integerwerts (oder mehr oder negativ)
> - Flushen eines Inputstreams, z.B. fflush(stdin)
> - Fehler bei Pointercasts (meist unnötig/obsolet)
> - usw.

# Sanitizer
- Compilerflags
- `-fsanitize=address` für Buffer OF und Dangling Pointer
- `-fsanitize=leak` für Mem Leaks
- `-fsanitize=undefined` für UB

> Nachteile der Verwendung von Sanitizer
- Erschwert Debugging mit anderen Tools
- Performanz des PRogramms wird deutlich verringert -> deaktivieren bevor perf tests
- Erkennen bei Weiterm nicht alle Fehler
- Funktioniert nicht bei handgeschriebenem Assembly