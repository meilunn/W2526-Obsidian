# Konzept
- Für Dezimalsystem
	- ![[Pasted image 20251122132242.png|325]]
	- -> $1 \leq Mantisse < 10$
- -> Für Binärsystem 
	- ![[Pasted image 20251122132532.png|350]]
	- -> $1 \leq Mantisse < 2$
# Aufbau
![[Pasted image 20251122125619.png]]
- Wissenschaftliche Notation 
	- $SignBit \times Mantisse \times 2^{Exponent-Bias}$

- Feste Anzahl an signifikanten Stellen
- Größerer Wertebereich als Fixkomma Zahlen
- Höhere Genauigkeit bei kleinen Zahlen
	- ![[Pasted image 20251122125849.png|335]]
	- ![[Pasted image 20251122132516.png|325]]
#### Exponent(gespeichert) = Exponent(real) + Bias
- Brauchen für Zahlen mit $|x| < 1$ negative Exponenten
	- Bias statt Zweierkomplement
	- Lexikografischer Vergleich statt Subtraktion und Vergleich mit 0
	- -> In der Theorie weniger Operationen
- Mit 8 bits 0-255 möglich, aber verschieben Range zu (-127)-127
	- gespeicherter Wert - 127 = wahrer Exponent

#### Mantisse
- $1 \leq Mantisse < 2$ (normalisiert)
	- muss also führende Eins nicht abspeichern
- Stellen in Mantisse sind $\frac{1}{2^1}, \frac{1}{2^2} = \frac{1}{4}, \frac{1}{2^3} = \frac{1}{8},\dots$

## float & double
![[Pasted image 20251122130501.png|525]]

# Rechnen 
## Addition & Subtraktion
- kleineren Wert auf selben Exponenten bringen wie großen Wert (denormalisieren)
- Mantissen addieren bzw subtrahieren
- Mantisse entsprechend der Genauigkeit runden
- Ergebnis normalisieren

- ![[Pasted image 20251122144045.png|326]]
	- normalisieren da Wert von Mantisse muss zwischen 1 und 2 sein, was bei 0.25 nicht der Fall ist

## Multiplikation & Division
- Exponenten addieren bzw subtrahieren
- Mantissen multiplizieren bzw dividieren (Führende 1 beachten)
- Mantisse entsprechend der Genauigkeit runden
- Ergebnis normalisieren

## Genauigkeit
- <u>Rundung</u>: Ergebnis muss wieder in FP-Darstellung gespeichert werden
	- Verschiedene Rundungsmodi, Standard: round to nearest, ties to even
	- -> liegt die Zahl genau in der Mitte dann zur nächsten geraden Zahl
- <u>Absorbtion</u>: Addition/Sub. von sehr großer und sehr kleiner Zahl
	- keine Veränderung der großen Zahl wegen Rundung
	- -> 1 000 000.00f + 0.01f = 1 000 000.00f
		- 1 Mio bereits 7 Ziffern, zu kleine Nachkommastellen werden also weggerundet
- <u>Auslöschung</u>: Subtraktion großer ähnlicher Zahlen
	- Subtraktion verstärkt Rundungsfehler
	- -> 1 000 000.1f - 1 000 000.0f = 0.125f != .1f
	- Grund: 1 Mio tatsächlich als 1 000 000.125 gespeichert, da nicht genug Stellen übrig sind um .1 noch darzustellen


> [!warning] 
> Sowohl Addition und Multiplikation sind 
> - NICHT assoziativ
> - NICHT distributiv
> -> `-Ofast` in GCC ignoriert diese zwecks Geschwindigkeit

> [D. Goldberg: What every programmer should know about floating-point arithmetic](https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf)

# Denormale Zahlen / Subnormale Zahlen
- Zahlen deren Exponent kleiner ist, als eine normalisierte Darstellung zulassen würde
- -> $1.0_{2}\times 2^{-127}$ ist in single precision, normalisert nicht darstellbar

- Denormalisiert: $0.1_{2}\times 2^{-126}$
	- -126 niedrigster wert des Exponents

> Darstellung
- Exponent alle Bits 0 und Mantisse hat wert
	- => Exponent = -126
	- => Mantisse hat führende 0 statt 1

# Special numbers
## Null mit Vorzeichen
- Null: Exponent und Mantisse alle Bits 0
- Sign-Bit kann trotzdem gesetzt sein -> +/-0 möglich

- Üblicherweise: $x+0 = 0$
- Sonderfall: $x = -0 \to -0+0 = +0$
	- technisch ein anderer wert
- $-0\neq+0$

## Infinity
- alle Bits in Exponent = 1
- alle Bits in Mantisse = 0
- -> Je nach Sign-Bit $+/- \infty$ 
- z.B. Ergebnis bei $\frac{x}{0}$

## NaN
- Alle Bits in Exponent = 1
- Mantisse != 0
- z.B. $\frac{0}{0}$ und $\infty-\infty$
	- undefinierte Operationen
- $x \circ NaN = NaN$,  $\circ$ ist jede Operation
- $NaN_{1} == NaN_{2} \to false$, für jeden NaN Wert


# Weitere Floating Point Formate
- 16 Bit half precision / `half`
	- ![[Pasted image 20251122152111.png|194]]
- Brain Floating Point / `bfloat`
	- ![[Pasted image 20251122152126.png|182]]
- Extended Formate
	- für spezielle Anwendungsgebiete mit besonderen Anforderungen (z.B. weniger Speicherplatz, mehr Genauigkeit etc.)