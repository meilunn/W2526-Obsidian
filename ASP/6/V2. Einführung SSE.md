# SSE-Register
- `xmm0` bis `xmm15` 
	- 16 weitere Register
- 128 Bit groß
	- -> für skalare Berechnungen sind nur die unteren 32 bzw. 64 Bit relevant
- verwendbar für Floating-Point Berechnungen

# Instuktionen
- XOR -> `pxor`

> Move
- `movss dst, src`
- `movsd dst, src`
	- (ss - scalar single, sd - scalar double)

- Moves zwischen General-purpose und xmm Registern möglich
	- `movd/movq`
	- Keine Konvertierung! Bit für bit
		- Gut für Bitmanipulation

- Wenn der zweite Operand ein Speicherzugriff ist, werden die Bits \[32; 127\] des xmm Registers auf Null gesetzt
- Wenn der zweite Operand ein Register ist, werden nur die Bits \[0; 31\] des Ziel-Registers geändert

# Arithmetik
- untere 32(/64) bit werden verwendet

- `addss dst, src`
	- src Register oder Speicher
- `subss dst, src`
- `mulss dst, src`
- `divss dst, src`
	- Multiplikation mit Kehrwert bevorzugen

> Conversion
- `cvtsi2ss dst (xmm), src`
	- convert Signed Integer 2 Scalar Single
- `cvtsi2sd`

- `cvtss2si dst, src (xmm)`
	- src bel. xmm Register

# Vergleiche
- `ucomiss op1, op1` - Skalarer Vergleich zweier Floating-Point Werte
- Flags gesetzt in Abhängigkeit des Ergebnisses
	- Ermögliche Sprünge mittls `jcc`
	- Aber: es werden condition codes für vorzeichenlose Vergleiche verwendet!
- ![[Pasted image 20251122162733.png|450]]
	- e.g. `jbe` auch möglich
	- `jnp` Gegenteil nov `jp`
		- p parity

# Calling Convention
- `xmm0` - Floating-Point Rückgabewert
- `xmm0 - xmm7` Floating-Point Argumente (weitere auf Stack)
	- Separate Durchnummerierung der Register mit Int/Ptr Argumenten
	- ![[Pasted image 20251122163908.png|350]]
		- (float am Anfang steht für Rückgabewert)
- alle Register sind CALLER-saved
