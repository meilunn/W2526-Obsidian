## Primitive Zeitmessung mit `time`
- Auf Konsole Eingabe mit `time <cmd>`
	- `time ./prog`
	- `time ls -a`
- Ausgabe 
	- `real 0m.024s` Abstand zwischen call und finish
	- `user 0m.016s` CPU-Zeit im User-Mode
	- `sys 0m.016s` CPU-Zeit im Kernel-Mode
- Nachteil: keine selektive Messung möglich
	- z.B. warten auf Eingabe zählt auch dazu
	- -> `time` ungeeignet für Performancemessung


# Zeitmessung im Code
- Wollen nur Dauer der tatsächlichen Berechnung/Algorithmus messen
	- -> keine unbegründeten I/O Funktionen usw. im Messbereich
- Abstand zwischen Messpunkten mindestens eine Sekunde
	- -> genügend Workload ggf. erschafften durch z.B. Schleifen
- Mindestens -O2

## Messen eines Zeitpunktes
- Genauigkeit der Messung abhängig von Genauigkeit der Zeitpunkte
	- Linearität der Uhrzeit darf nicht unterbrochen werden (z.B. durch Interrupt)
- `{c} int clock_gettime(clockid_t clk_id, struct timespec *tp)`
	- return 0 falls erfolgreich, -1 sonst
	- clk_id: `{c} clockid_t CLOCK_MONOTONIC`
	- \*tp: `{c} struct timespec{time_t tv_sec; long tv_nsec;}
	- -> into Sekunden mit: `{c} double sec = tv_sec + 1e-9 * tv_nsec;`

```c
// Beispiel korrekt

#include <stdio.h>
#include <time.h>

int main(int argc, char **argv) {
	struct timespec start;
	clock_gettime(CLOCK_MONOTONIC, &start);
	
	foo();
	
	struct timespec end;
	clock_gettime(CLOCK_MONOTONIC, &end);
	
	double time = end.tv_sec - start.tv_sec + 1e-9 * (end.tv_nsec - start.tv_nsec);
	
	printf("done after %f seconds", time);
	return 0;
}
```

```c
// Beispiel ungeeignete Schleife

struct timespec start;
clock_gettime(CLOCK_MONOTONIC, &start);
float res = 0;
for(int i = 0; i < 100000000; i++) 
	res = sqrt(5);
struct timespec end;
clock_gettime(CLOCK_MONOTONIC, &end);

// res bleibt nach der ersten Berechnung unverändert 
// -> Schleife kann wegoptimiert werden 
// -> Abstand zwischen Messpunkten zu gering
```


