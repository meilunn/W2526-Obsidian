# 64-Bit Register
- Variablen im Prozessor
- Variablen haben keine explizite Datentypen
	- Typ nur dadurch erkennbar an wie man sie verwendet

### 16 verschiedene General-Purpose-Register
- Für allg Berechnungen
- Keine besondere Fkt in der HW
- ![image1|500](36deeb4b4dc2465cbd4c70fd77abeacc.png)

### Register mit besonderer Funktionalität
- Instruction Pointer Register ``rip``
- Zeigt auf die nächste instruction die das Programm ausführt

# Grundlegende Instruktionen
- ![image2](759ab18aa73e47d3938d5d223b14a2ce.png)
	- mov KOPIERT, src wird nicht verändert

# Immediates
- Konstante, die man bei manchen Befehlen als Operant verwenden kann
- ![image3](2c136d94b40a4d6191b90d17145278e5.png)

- Mehrere mögl Schreibweisen
	- Dezimalzahl: add rax, 122
	- Hexadezimal: add rax, 0x7a
	- Binär: add rax, 0b1111010
	- Entsprechender Wert von ASCII Zeichen: add rax, 'z'
	
	- -> Alles ist rax = rax + 122

- 32 Bit groß, auf 64 Bit <u>sign-extended</u>
	- Wertebereich von Immediates also $\left\lbrack-2^{31},2^{31}-1\right\rbrack$

- ``mov`` verwendet 64 Bit Immediates, alle anderen Befehle 32
	- Falls man also eine Konstante benutzen muss, die sich nicht mit 32 bits darstellen lässt, kann man die dann erst in ein Register mit mov kopieren, und dann den Register nehmen fürs Addieren
	- -> alle Immediates müssen auf 32 Bit verkleinerbar und wieder auf 64 Bit extended werden können, ohne, dass sich dabei ihren Wert verändern

# Sign Extention
- -> Zweierkomplement
- Gegeben 32 bit Zahl mit $obd_{31}\ldots d_1d_0$
- $d_{31}$ nehmen und auf Bits 32-63 kopieren
- Beispiele
	- ``0xFFFFFFFF`` (``0b11111111111111111111111111111111``) wird zu ``0xFFFFFFFFFFFFFFFF``, da das oberste Bit eine 1 ist
	- ``0x80000000`` (``0b10000000000000000000000000000000``) wird zu ``0xFFFFFFFF80000000``, da das oberste Bit ebenfalls eine 1 ist
	- ``0x0000000A`` (``0b00000000000000000000000000001010``) jedoch wird zu ``0x000000000000000A``, das das oberste Bit eine 0 ist

# Flags
- Benutzt man in assembly um Werte zu vergleichen -> `cmp` 
- Flags register (rflags)
	- Spezielles Register im Prozessor
	- Wird nur indirekt benutzt
	- Beinhaltet mehrere Flags
	- Wird nach den meisten Instruktionen automatisch gesetzt

- Nach Addition und Subtraktion
	- Zero (ZF)
		- wenn das Ergebnis 0 ist
	    - Nach Subtraktion, wenn beide Werte gleich groß sind
	- Sign (SF)
	    - Wenn das Ergebnis negativ ist
	- Carry (CF)
	    - Unsigned overflow (positive infinity)
	    - z.B. bei $2^{63} + 2^{63} = 0$ gesetzt
	- Overflow (OF)
	    - Signed overflow (negative infinity)
	    - z.B. bei $(2^{63} - 1) + 1 = -2^{63}$ gesetzt

- Man kann auch anhand der Flags erkennen, welcher Wert größter ist
- ![image18|600](6bf239a7560340f7a201d27351623030.png)

# Condition Codes
- ![image9|350](db3d0b28f3064391b7c9989366b7d18c.png)
	- nz - not zero
	- Nach einer Subtraktion (cmp)

## CMP
- Compare
- Funktioniert wie SUB, verwirft aber das Ergebnis und setzt Flags

## Label
- Markiert eine Adresse
- Für Sprünge

- Globales Label
	- Anfang von Funktionen, globale Variablen, Konstanten
	- z.B. quicksort:
- Lokales Label
	- Label innerhalb einer Funktion
	- z.B. .Lloop: -> .L + name + :

## JMP/Jcc
- Springt zu Label
- "jmp labelname" oder "jmp .Lname" -> ohne `:`

- Jcc ist bedingter Sprung
	- cc wird durch condition code ersetzt (z.B. e, le, etc) -\> z.B. je .Lequal
	- Folgt auf ein cmp Befehl

## If Bedingung
- ![image10|500](b76eca1f0113436ea47c721d7b1d1a8c.png)

# Teilregister
- Nur einen Teil des Register benutzen um Rückwärtskompatibilität zu gewährleisten

- ![image11|550](1ea0299dbd2d45b188c8ad56ae3b7ebd.png)
	- rax: 64 Bits
		- eax: 32
			- ax: 16
				- ah & al: 8

- Bei zugriff auf 32 Bit Teilregister in einem 64 Bit Register werden die oberen 32 auf 0 gesetzt, bei den restlichen NICHT

# Weitere Operationen

## Bitweise Operationen
- ![image12](21aedb500030479fb6cc48d4bcb2b540.png)

- Auch mit Immediates möglich
	![image13](73a3795042554bcabcc55800f913f427.png)

## (Erweiternde) Multiplikation
- Selten benutzt
- Bei 64 x 64
	- ![image14](ffe34c92d8a74f1e8c016886788496e5.png)
	- Falls nur ein argument wird immer rax impliziert
- Bei kleineren Größen
	- ![image15](810c29f2a7f64ad9a300475ed8ddfd18.png)
	- Jedoch sinnlos, da man das auch einfach als nicht erweiternde Multiplikation eines größeren Registers implementieren kann

## Division

> [!warning] Keine Division mit Immediate Operanden!

- ![image16](2bfdf2445ff344df8f5f0c2f4bd9b2c9.png)
	- rdx:rax jeweils obere und untere Hälfte des Zählers (rcx Nenner)
	- Ergebnis in rax, Rest in rdx

- Exception wird geworfen falls
	- Dividend 0
	- Ergebnis lässi sich nicht im Zielregister darstellen
- Divide sehr teuer

----
# Wichtige Instruktionen im Überblick

![image17](5c9d627b148b4b2d83bbf0e363c111d4.png)
- shl, shr - bit shift
- cmovcc dst, src - mov src to dst if cc is true
	- if no cmp then uses last flag op

| cc  | Flags checked      |
| --- | ------------------ |
| ge  | SF = OF            |
| g   | ZF = 0 and SF = OF |
| le  | ZF = 1 or SF != OF |
| l   | SF != OF           |
| e   | ZF = 1             |
