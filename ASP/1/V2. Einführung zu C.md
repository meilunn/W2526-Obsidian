
> [!tldr] 
> Datentypen
Kontrollfluss
Programmstruktur


- Nicht objektorientiert

# C Standard
- Defininiert die Anforderung die an eine ==konkrete Implentierung== des Standards gestellt werden
- Muss möglichst rückwärtskompatibel sein, damit ältere Programme auch immernoch standardkonform sein können

> Konkrete Implementierung
- Gesamtheit der Konponente die für das Entstehen und Ausführen eines Programmes verantwortlich sind
- Umfasst also Compiler, Standardbib, Betriessystem, Hardware (Prozessor)

## Arten von Behaviour
- "Standard defined behaviour"
	- Durch den Standard eindeutig definiertes Verhalten
	- z.B. for loop ist `for(init; condition; increment)`, wie `{}` und scopes funktionieren
- "Implementation-defined behaviour"
	- Verhalten, die abhängig sind von den Komponenten und deswegen nicht von Standard festgelegt werden können
	- z.B. konkrete Größen der Basisdatentypen -> int kann 16, 32, oder 64 bits sein, long kann 32 oder 64 Bits groß sein

# Grundlegende Datentypen

## Integer
- Diese Datantypen können benutzt werden zur Darstellung von ganzen Zahlen
	![image1|525](afa8ec8f66164c7180387122ffa62c50.png)
	- char per Def 1 Byte, alle anderen Größen von Datentypen sind implementierungsabhängig

- Datentypen standardmäßig vorzeichenbehaftet
	- Außer char und \_Bool -> sind impl.-defined
- Man kann jeweils `signed` und `unsigned` als keyword benutzen
	- Einfach nur "unsigned" impleziert int
	- ![image2](7400add0cd114e2781ef0cd2e9564559.png)

- Vorzeichenlose Zahlen haben größeren positiven Wertebereich
	- Können dafür keine negative Zahlen darstellen

> [!info] Overflows nur für *vorzeichenlose* Zahlen definiert

> [!info] Wird einem \_Bool ein Wert != 0 zugewiesen, wird dieser Wert automatisch zu 1 konvertiert

## Floating-Point
- ![image3](ec846a737a0341188d558d566cbbe18c.png)
- Stehts vorzeichenbehaftet

## Void
- Leerer Datentyp
- steht für "kein Rückgabewert" oder "keine Parameter"

# Pointer
- Speicheradresse, die mit einem bestimmten Datentyp verknüpft ist
- Größe ist plattformabhängig, hier 64 bit
- Arrays und strings werden immer durch pointer dargestellt, da string ist array of chars

- `void*` ist Platzhalter für beliebigen Datentyp vom Pointer
	- z.B. bei einem Funktionsparam
	- Nicht direkt verwendbar um Daten auszulesen

- ![image4|223](feeb7b6c2aca4947a0ef8f1e2c4d9511.png)

# Funktionen
- In C einziges Konstrukt was ausführbare Programmlogik enthält
- Müssen vor Aufruf deklariert und definiert werden
	- Kann getrennt oder zusammen passieren
	- ![image5](756d0434dba04920881dc80aa1bc7b06.png)

> [!warning] Void
> Bei Deklaration von Fkt ohne Parameter muss void in die Klammer, sonst kann die Fkt mit beliebigen Parametern definiert/aufgerufen werden!
> ```c
> int func(void)
> {
> 	return 1;
> }
> ```
## Main Funktion
- `int main (int argc, const char** argv)`
	- argc = arg count
	- argv sind die Argumente, wobei `argv[0]` der Name des Programmes ist
### Rückgabewerte
- Standardisierte Konstanten `EXIT_SUCCESS` und `EXIT_FAILURE`
	-> unabhängig der Impl
- Ansonsten 0 für success, 1 für allgemeiner Fehlercode, oder anderer kleiner Integer der je nach Kontext eine bestimmt Bedeutung haben kann
    -> Implementation-defined error code

# Variablen
- Deklaration = alloziert Speicherplatz
	- Bleibt bis zur Zuweisung undefiniert
- `const` muss immer gleich zugewiesen werden, da er sonst nicht mehr verändert werden kann (^= final in Java)

## Scopes
- ![image6|500](4d31830adde5438f81b5c979c3c4667a.png)

## Zuweisung von konstanten Werten
- ![image7](3d08a381f5c243fdaeb91535cef6e292.png)
  - -> Implizite Konversion

## Arithmetische und logische Operatoren
- ![image8](8f2d97755ca8411e98364aaddd6bbfea.png)
	- true/false Operatoren wie && geben immer int zurück mit entweder 0 oder 1

# Kontrollflussstrukturen
- If else
- While, do-while
- Break, continue
- For
	- ![image9](05717ab1e1a44296bb12d1d5db9f08f3.png)
	- Jeder der drei Teile kann weggelassen werden

- Switch
	- ![image10](0113dd8628b94e37950b53736666e22b.png)

> [!warning] Fall through
> Ohne "break" am ende von einem Fall wird nicht beendet, sondern mit dem nächsten Fall weitergemacht -> sogenannt "fall through"

# Preprocessing
- Vor dem Einsatz vom Compiler
- cpp ist ein Präprozessor
- Führt Direktive aus
- Löst Makros auf
- Befehle für den Präprozessor im Code beginnen immer mit \# und haben kein ; am Ende

- ![image11](231d72e2e68f47b3b138357055224433.png)
	- `# define` und `#undef` sind directives
	- NUMBER is macro for 42
	- Text wird direkt ersetzt, nicht verarbeitet (Zeile 5)

- `#if else`
	- ![image12](98c9e23c8c28421582f4e57557dc14f5.png)
	- Mit if-else kann man in verschiedenen Bedingungen verschiedener Code kompilieren lassen

- `#include`
	- ![image13](40f95ef854024aedb2759b1591d213a7.png)
	- use <> if lib is from C standard lib
	- "" if it's from own proj

# Header-Dateien
- ![image14|500](b8ec6bb3766c47e6a9fc25869b9e9787.png)
- Gut um code zu strukturieren und organisieren

# Sichtbarkeit
- Storage class specifier static & extern
	- Extern immer implizit gegeben ~ public
	- Static ~ private
- ![image15|500](7fa8c13233c74816b78f23418e143a17.png)

# Standard-Header
- Nutzung der Standardbibliothek
	- Kein "Import System"
	- Nur über Header

- ![image16](c94d237fa7a741b1a69b82995c05d75b.png)
	- `size_t` wird für Größeangaben von Speicher benutzt
	    -> es kann kein Objekt geben, dessen Größe größer als das größtmögliche Wert von size_t ist

## Wichtige Libraries
### stdint.h
- In der C Standardbib
- Definiert fixed-width Integer Typen
    - -\> Größe der Datentypen nicht mehr HW abhängig
    - -\> mehr Kontrolle
  - ![image17|350](666ffa2603fc4389aecf660c1cd453f4.png)

### stdbool.h
  - `bool` als Synonym für \_Bool
  - `true` und `false` als Synonyme für die Integer Konstanten 1 und 0
  - -> quality of life

### stdio.h - printf
  - `int printf(const char* format, …);`
  - format ist Format String
  - ![image18|450](c400e516d5834afca6cb65c7f753435e.png)

- Conversion specifiers
	- ![image19](ac02f66b8c724228a9eb42151508b84d.png)

- Optionale Angabe eines Length modifiers vor dem conversion specifier
	- Bedeutung davon hängt dann vom angehängten Datentyp des conversion specifier ab
	- z.B. %ld für einen long int

> [!warning] printf("\n")
> printf IMMER mit \n schreiben, sonst kann die Ausgabe in einen Zwischenspeicher (Buffer) landen

- `PRIx64`
	- ein Makro das in inttypes.h definiert ist
	- ermöglichet hexadezimale Ausgabe von fixed-width 64-bit unsigned Integer
	- ![image20](6107ad5e5bd74d128d5fd69f88cae45b.png)
		-> x ist hier ein uint64_t