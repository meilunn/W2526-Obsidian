- single instruction multiple data

> [!question] Leitfrage
> Gibt es eine Möglichkeit Daten abseits von Threading parallel zu verarbeiten? 
- bisher: SISD - Single instruction stream single data stream
	- funktioniert, aber nicht optimal
	- führt der Reihe nach aus

> Lösung: *Vektorisierung*
- Anwendung der selben Instruktion auf ganzen Satz aus Datenobjekten
- -> Neue SSE-Befehle für Vektorverarbeitung

# SSE-Instruktionen für SIMD
- Instruktionen arbeiten auf ganzem XMM-Register (128 Bit) zur gleichen Zeit
	- kein effekt auf nebenstehende Daten im XMM-Register
- KEINE Speicher zu Speicher Operation
- Schlüsselwort: **Packed (P)**
	- keine einheitliche Position für Integer und Float

## Integer Instruktionen
- `PADDD xmm1, xmm2/m128` - Add Packed Integer <u>DWORD</u>
	- addiert 4 dword ints auf 4 andere dword ints
	- jeweils unabhängige operationen -> dword 1 wird nicht von overflow usw. bei dword 2 beeinflusst
	- ![[Pasted image 20251127162624.png|350]]
- `PADDB xmm1, xmm2/m128` - Add Packed Integer <u>Byte</u>
	- 16 Byte ints auf 16 andere Byte Ints
- `PADDQ xmm1, xmm2/m128` - Add Packed Integer <u>QWORD</u>
	- 2 QWORD Ints auf 2 andere QWORD Ints

## Gleitkomma Instruktionen
- `ADDPS xmm1, xmm2/m128` - Add Packed <u>Single</u>-Precision Floating-Point
	- add 4 floats auf 4 andere floats
- `ADDPD xmm1, xmm2/m128` - Add Packed <u>Double</u>-Precision Floating-Point
	- add 2 double auf 2 andere double

# Alignment
- die meisten SIMD-Instruktionen erfordern ein **16Byte** Alignment
	- -> Adressen müssen durch 16 teilbar sein
		- in hex letzte Ziffer 0, in binär letzte vier Ziffern 0
	- Exceptions bei Zugriff auf non-aligned Speicherbereich
	- Alignment von Variable und Structure-Fields in C mittels
		- z.B. `{c} int x[12] __attribute__((aligned (16)));`
- Vorteil
	- Daten können passgenau in eine Cache-Line gebracht und aus dieser abgerufen werden
	- es können mehrere 16 Byte Blöcke an Daten in eine Zeile des Caches geladen werden, je nach größe der Zeile

## (Un)Aligned Zugriff
- `MOVAPS xmm/m128 xmm/m128` - Move Aligned Packed Single-Precision
	- Kopiert 4 floats von src nach dst
	- ==Speicher-Operanden== müssen aligned sein
	- Kann auch 4 Int, 2 Double oder 2 Long kopieren -> dafür auch gesonderte Instruktionen wie `MOVDQA`
- `MOVUPS xmm/m128 xmm/m128` - Move Unaligned Packed Single-Precision
	- kopiert 4 floats von src nach dst, auch wenn Addresse nicht aligned ist
	- Geschwindigkeit
		- langsamer als MOVAPS bei unaligned Zugriff
		- auf modernen CPUs auf aligned Speicher gleich schnell wie MOVAPS
	- -> Um Zweifelsfall MOVUPS verwenden, bei Kenntnis MOVAPS

# SIMD Stolperfallen
- auf günstigen CPUs ist SIMD evtl langsamer
- Höhere Leistungsaufnahme/Temperatur, da mehr Operationen gleichzeitig = mehr Stromverbrauch
- Zusätzlicher Overhead für SMD muss sich auch lohnen
	- SIMD Berechnungen finden außerhalb des standard Rechenwerkes statt -> Wechsel zwischen SIMD, SSE und standard Befehlssatz = Kontextwechsel = kostet mehr Zeit
	- Algorithmen müssen manchmal speziell für SIMD angepasst werden -> zusätzliche Arbeit
	- nicht jeder Alg ist für SIMD geeignet 
		- z.B. welche mit variierender Control-Flow -> große Anzahl an bedingten Sprüngen zu vielen verschiedenen Teilfällen
- Verwendung von Befehlssatzerweiterungen wie SSE, AVX und FMA kann Kompatibilität einschränken

# Compiler und Vektorisierung
- compiler versuchen Programmcode automatisch zu vektorisieren
- bis 2020 (nach ca.20 Jahren) der Entwicklung weiterhin schwere Aufgabe für Compiler
	- Problemstellung ist komplex und Ergebnis oft nicht optimal

> Wenn Vorteil von SIMD für Problemstellung ersichtlich, dann sich NICHT auf den Compiler verlassen! 
- -> [[V2. SIMD mit C#Intrinsics|Intrincsics]]


