# Intrinsics
- neue Datentypen `__m128, __m128d, __m128i` (128 Bit groß)
	- kein bestimmter xmm Register, Wert kann aber in eins reingeschrieben werden

| Assembly         | Intrinsic                                                                        |
| ---------------- | -------------------------------------------------------------------------------- |
| `addps xmm, xmm` | `{c} __m128 _mm_add_ps (__m128 a, __m128 b)`                                     |
| `addpd xmm, xmm` | `{c} __m128d _mm_add_pd (__m128d a, __m128d b)`                                  |
| `paddb xmm, xmm` | `{c} __m128i _mm_add_epi8 (__m128i a, __m128i b)`                                |
| `psubq xmm, xmm` | `{c} __m128i _mm_sub_epi64 (__m128i a, __m128i b)`                               |
| `mulss smm, xmm` | `{c} __m128 _mm_mul_ss (__128 a, __m128 b)`                                      |
| Load (aps)       | `{c} __m128 _mm_load_ps (float const* mem_addr)`                                 |
| Store (aps)      | `{c} void _mm_store_ps (float* mem_addr, __m128 a)` <br>-> Store a into mem_addr |
> -> [Intel intrinsics guide](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html)

#### Beispiele
Simple load
```c
float b = 6.7f;
__m128 x = _mm_load_ss (&b);  // <- mem_addr
```

$y \leftarrow \alpha * x + y$
```c
#include <immintrin.h>

void saxüy(long n, float alpha, float* x, float* y) {
	__m128 valpha = _mm_load1_ps(&alpha);  // loads one val 4x
	for(size_t i = 0; i < n; i += 4) {  // da 4 Elem auf einmal processed werden
		__m128 vx = _mm_loadu_ps(x + i);
		__m128 vy = _mm_loadu_ps(y + i);
		
		vy = _mm_add_ps(_mm_mul_ps(valpha, vx), vy);
		
		_mm_storeu_ps(y+i, vy);
	}
	
	for(size_t i = (n-(n%4)); i < n; i++) {  // für den rest
		y[i] = alpha * x[i] + y[i];
	}
}
```

## Vor- und Nachteile
- Abstraktion von Assembly
	- Bessere Lesbarkeit und Wartbarkeit
	- Freiraum für Compileroptimierungen
- Verlust der Plattformunabhängigkeit

# Automatische Vektorisierung
- GCC automatisch ab -O3
- `-march=native`
	- Spezifizieren welcher Erweiterrungssatz verwendet werden soll
	- native = alle Erweiterungssätze der lokalen Architektur müssen unterstützt werden
- `-fopt-info-vec(-missed)` 
	- welche Vektorisierungen erfolgreich waren
	- welche Schleifen nicht vektorisiert werden konnten
- Resultat nicht immer effizienter als händische Implementierung
	- -> Code mit `objdump` analysieren

> restrict