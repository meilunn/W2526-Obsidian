- Laufzeitverhalten von Programmen werden betrachtet, um effiziente Problembereiche aufzudecken
	- Geschwindigkeit, Speichernutzung, Nebenläufigkeit

# Tracing Profiler
- fügen Instruktionen zum Programmcode hinzu
	- kann im source code, assembly oder zu laufzeit
- präzise Angaben, wie viel Zeit in welcher Funktion verbracht werden
- Ausführung braucht jedoch länger

# Sampling Profiler
- source code wird nicht verändert
- Profiler greift in regelmäßigen Abständen in Programmablauf ein, protokolliert Ereignisse seit der letzten Stichprobe (u.A. auch die Addresse, wo sich das Programm gerade befindet)

![[Pasted image 20251127210233.png|600]]

- `perf record ./<exec>` 
	- `-i <num iterations>` e.g. 50 iterations
- `perf report`
	- ![[Pasted image 20251127210753.png|575]]
	- erste Spalte ist Dauer
	- zweite Spalte ist Prozess (perf kann auch Systemweit laufen)
	- \[.], \[k] is priviledge level 

- Annotate compute
	- zugehöriger C code kann nur angezeit werden falls Programm mit -g kompiliert wurde

- `perf list` - list of events that are recorded
- `perf record -e <event> ./<exec> -i 50`
	- e.g. cache-misses
	- can then be seen in annotate compute
- `perf stat -e cache-misses ./<exec> -i 50` - show stats

----
# CPUs pre-loading
- e.g. matrix (array of array)
- Zugriff auf a\[0]\[0] -> CPU lädt dann a\[0]\[1] in den cache 
	- -> hohe Wahrscheinlichkeit dass das als nächstes gebraucht wird
- pre-loading passiert im Hintergrund, verbrauchte Ressources können vernachlässigt werden 
	- kann also ausgenutzt werden um Programm schneller werden zu lassen

### Cache-miss
![[Pasted image 20251127212553.png|550]]
- Programm inkrementiert erstmal i bei a\[i]\[j]
- pre-loaded Sachen werden also gar nicht sofort benutzt
- bis das Programm bei a\[0]\[1] ankommt kann es auch sein, dass es gar nicht mehr im Cache ist -> muss erneut geladen werden