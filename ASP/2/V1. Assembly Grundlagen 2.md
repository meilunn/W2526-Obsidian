# Speicherzugriffe

> Beispiel
- `add dword ptr [rax], 1`
	- `[rax]` - Speicheroperand
		- enthält Adresse/Pointer
		- Wert davon wird dann benutzt
	- `dword ptr` - Pointer Typ 
		- auf was für ein Datentyp der Pointer in rax zeigt
		- dword hier 32-bit
		- -> damit die Operation auf dem korrekten Anzahlt an Bytes im Speicher ausführen zu können
	- addiert 1 zum Wert der Adresse, auf die rax zeigt

# Speicheroperand

> Allgemein: 
- Register/Immediates häufig durch Speicheroperanden austauschbar
- Aber: max. ein (expliziter) Speicheroperand pro Instruktion
- `mov` zum laden/schreiben von Werten aus/in den Speicher 
	- (falls man noch einen Speicherzugriff benötigt)
	- können Speicheroperand auch als Quell- oder Zieloperanden angeben

- ![[Pasted image 20251023012321.png|206]]
	- 32-bit Wert an der Adresse rdi auf 32-bit Wert an der Adresse rsi addieren
	- mov wird gebraucht weil `add [rsi], [rdi]` ist nicht möglich

- `mov rax, [Base + Index * Scale + Displacement]` -> 3 Komponente

| Komponente   | Wert        | Bedeutung                                                                            |
| ------------ | ----------- | ------------------------------------------------------------------------------------ |
| Base         | 64-bit Reg. | (Basis-)Adresse eines Pointers/Arrays                                                |
|              |             |                                                                                      |
| Index *      | 64-bit Reg. | Index eines Array Elements                                                           |
| Scale        | 1, 2, 4, 8  | bestimmter Größe in ==Byte== (je nachdem was für ein Datentyp im Array)              |
|              |             |                                                                                      |
| Displacement | 32-bit Imm. | Statischer Offset (z.B. wollen auf das 2. Byte einer 4 Byte großen Struct zugreifen) |
- Alle Komponenten optional (bzw. mind. ein Komponent muss nicht 0 sein)
- Default Base, Index * Scale und Displacement ist 0 

#asp/important Speicheroperand

## rip-relative Adressierung

- `mov rax, [rip + Displacement]`
	- Basisregister ist instruction pointer register (64 bit)
	- können keinen (skalierten) Index angeben
	- 32-bit Displacement
		- häufig Label: `mov rax, [rip + my_label]`
		- -> berechnet die ==relative Adresse== von `my_label` zu `rip`

> Position-Independent Code
- Man kann also z.B. hardgecodete Werte unter einem Label laden, dessen tatsächliche Adresse nicht bekannt ist
- Best practice ist immer PIC zu schreiben

## Zugriffsgröße - `size`

- `mov size ptr [rax], 1`

- gibt Größe des Werts im Speicher an
- Nötig wenn Größe nicht implizit ersichtlich ist
	- z.B.`mov byte ptr [ax], 42` (Immediate "42" ist 1 Byte groß)
- Optional wenn Größe implizit ersichtlich ist
	- z.B. `mov [rax], cx` (cx ist 2 Byte groß)
	- z.B. `mov word ptr [rax], cx` man kann `size` aber trotzdem angeben

> [!important] `ptr` nicht vergessen! 
> Bei Angabe von size MUSS ptr dazugeschrieben werden, sonst wird size als Displacement interpretiert

> Einige Pointer Typen

| `size` | byte | word | dword | qword |
| ------ | ---- | ---- | ----- | ----- |
| Bytes  | 1    | 2    | 4     | 8     |

# lea
- Load Effective Address
- `lea rax, [rdi + 2*rsi + 1]`
	- nimmt ein Reg und ein Speicheroperanden entgegen

- greift *nicht* auf den Speicher zu
- schreibt Ergebnis der Berechnung des Speicheroperanden in Zielregister
- Eignet sich zum Berechnen von Adressen oder zum effizienten Berechnen einiger arithmetischer Ausdrücke
	- Beispiel
	- ![[Pasted image 20251023170649.png|241]]
	- beides berechnet `eax <- edx + 4*ecx - 2`

# Shifts
- verschieben nach links oder rechts

> `shr/shl reg/mem, imm8/cl` (cl ist Register)
- logischer Shift
- i-bit shift = Multiplikation mit 2^i 

> `sar/sal reg/mem imm8/cl` 
- arithmetischer Shift (bei signed und Rechtsshift)
	- wenn negativ (vorne schon eine 1) dann wird vorne mit 1 aufgefüllt
	- wenn positiv (vorne 0) dann wird mti 0 aufgefüllt
- rundet negative Zahlen ab (Richtung $-\infty$)
	- ![[Pasted image 20251023172210.png|450]]

 >[!warning] `sar` für unsigned Zahlen i.A. falsch! -> `shr` verwenden
 >Zwischen `sal` und `shl` gibt es keinen Unterschied.
 
 