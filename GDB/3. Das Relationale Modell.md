- E.F.Codd bekam Turing Award für die Entwicklung
- weitverbreitestes Datenmodell
- wird nach und nach um objekt-orientierte Konzepte erweitert -> obj-relationales Modell
## Definitionen
- relationaler Datenbank enthält eine ==Menge von Relationen==
- #gdb/def Relation R
### Relation *R*
- zwei Bestandteile
- Instanz *R*
	- Aktuelle Inhalt der Relation
	- Die Tabelle mit Zeilen und Spalten
	    - Zeile = Tupel oder row
	    - Spalte = Attribut
- Schema *R*
	- Beschreibt Struktur der Relation
	- Namen der Relation
	- Namen & Datentypen der Spalten

#### Formale Definition Relation
  - Eine Relation (Instanz) ist eine Untermenge des kartesischen Produkts der Domänen (Attribute)
    - $R\subseteq D_1\times D_{2}\times\dots \times D_{n}$
  - Relation ist eine *Menge*
    - Keine Reihenfolge (-> man bekommt nicht immer dieselbe Ausgabe bei der selben Anfrage, kann aber Reihenfogle spezifizieren)
    - Keine Duplikate
- Die Größe einer Relation (Anzahl Tupel) ist ==Kardinalität== 
- Die minimale Menge von Attributen, deren Werte ein Tupel eindeutig identifiziert, heißt ==Schlüssel== 
- Der *Primärschlüssel* wird unterstrichen
	- Student(<u>MatrNr</u>, Name, Geburtstag)

### Beispiel Schema der Relation/Table Student
- Drei Attribute MatrNr, Name, Geburtstag
- Assoziert mit jedem Attribut ist eine Domäne (Wertebereich)
	- $D_{MatrNr}=\text{integer}$
	- $D_{Name}=\text{string}$
	- $D_{Geburtstag}=\text{date}$
- Komplettes Schema: `Student(MatrNr:integer, Name:string, Geburtstag:date)`
- Relation Student formal: 
	- $\text{Student}\subseteq D_{MatrNr}\times D_{Name}\times D_{Geburtstag}$
	- $=Student\subseteq \text{integer}\times \text{string}\times \text{date}$

# Anfragesprachen
- DBS benutzt intern relationale Algebra
## Relationenkalkül
- wird von Benutzer benutzt, intern zu relationale Algebra umgewandelt
- Rein deklarative Sprache
- Ursprünglich mit dem relationalen Modell von Codd entwickelt worden
- Bildet Grundlage von SQL
## Relationale Algebra
- Stärker prozedural orientiert
- eine Variante davon wird auf der physischen Ebene eingesetzt, um Anfragepläne zu bauen
- DBMS selbst arbeitet nicht deklarativ

- Mengenorientiert und abgeschlossen
	- Jeder operator bekommt als Eingabe eine (oder mehrere) Mengen von Tupeln, also eine Relation
	- und ibt eine Menge von Tupeln aus, also eine Relation
- ![[Pasted image 20251020183942.png|375]]


## Befehle #gdb/important 
### Projektion
- $\pi_{A1,\dots,An}(R)$
- Wählt Attribute (Spalten) $A_1, \dots, A_n$ aus Relation R aus
- Filtert alle anderen Attr aus
- Duplikate werden eliminiert (da Menge)
  - ![image7|400](224fc486bcee4ff6b23712ea65abf470.png)
### Selektion
- $\sigma_{p}(R)$
- Wählt alle Tupel aus R aus, die das Prädikat p erfüllen
	- p können mit logischen Operatoren kombiniert werden
	- Vergleichsoperatoren sind die üblichen
	- z.B. $x=y \wedge x<7$
### Kreuzprodukt
- Wenn Information aus mehreren Relationen benötigt wird
- z.B. $R_1\times R_2$
- auch kartesisches Produkt genannt
- Teuere Operation, da man jeder Tupel aus $R_1$ mit jedem Tupel aus $R_2$ vergleichen muss
### Join
- Unsinnige Kombinationen des Kreuzprodukts kann man mit einer nachgeschalteten Selektion ausfiltern
- Effizienter implementierbar als Kreuzprodukte
- Join operator: $\bowtie$
	- Beispiel: $R_{1}\bowtie_{R_{1}.A_{i}=R_{2}.A_{j}}R_{2}=\sigma_{R_{1}.A_{i}=R_{2}.A_{j}}(R_{1}\times R_{2})$
- Beispiel Anfrage "Gib alle Vorlesungen zusammen mit den zuständigen Professoren aus"
	- $Vorlesung\bowtie_{ProfPersNr=PersNr}Professor$

>[!warning] Alle Attributnamen im Befehl müssen eindeutig sein
> Falls Attribute von zwei Relationen den gleichen Namen haben, muss man einen umbenennen mit dem Umbenennungsoperator $\rho$
- Beispiel
	- Assistent(PersNr, Name, Fachgebiet, Boss)
	- Professor(PersNr, Name, ZimmerNr)
	- $Assistent\bowtie_{Boss=PersNr} Professor$
	- -> Welche PersNr?
	
	- $\rho_{APersNr\leftarrow PersNr, AName\leftarrow Name}(Assistent)$
		$\bowtie_{Boss=PPersNr}$
		$\rho_{PPersNr\leftarrow PersNr, PName\leftarrow Name}(Professor)$

#### Klassifizierungen
- Theta-Join ($\theta$-Join) 
	- ineffizient
	- die allgemeinste Art
	- Joinprädikat dard beliebige Vergleichsoperatoren enthalten
- Equi Join 
	- hat bestimmter Algorithmus für Effizienz
	- Joinprädikat darf nur auf Gleichheit (=) prüfen
- Natürlicher join
	- spezielle Art des Equi-Joins, die nur Attribute mit gleichen Namen vergleicht (und redundante Spalten wegprojiziert)
	- wird nicht von computern verwendet, da alle elemente intern unique namen haben -> nur "eye-candy" für Menschen
- Äußerer Join (outer join)
	- falls ein Tupel keinen Joinpartner in anderen Relationen findet, geht es verloren
	- im äußen Join bleiben diese Tupel erhalten
	- es gibt dann Felder mit fehlenden Werten 
	- ![[Pasted image 20251020190850.png|450]]

	- Linker Äußerer Join
		- nur Tupel aus der linken Relation die ggf keinen Joinpartner haben werden behalten
		- ![[Pasted image 20251020190952.png|450]]
	- Rechter äußerer Join
		- vice versa
		- ![[Pasted image 20251020191028.png|450]]
- Semi-Join
	- prüft Joinbedingung, behält dann aber nur Tupel aus einer der beiden Relationen (die die Bedingung erfüllen), je nachdem welche Seite man möchte
	- ![[Pasted image 20251020191311.png|450]]
- Anti-Join
	- prüft die Joinbedingung, behält nur Tupel aus einer der beiden Relationen (die die Bedingung *nicht* erfüllen)
	- ![[Pasted image 20251020191428.png|450]]

### Mengenoperationen